var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#AlgebraicPetri","page":"Library Reference","title":"AlgebraicPetri","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri]","category":"page"},{"location":"api/#AlgebraicPetri.AlgebraicPetri","page":"Library Reference","title":"AlgebraicPetri.AlgebraicPetri","text":"Computing in the category of finite sets and Petri cospans\n\n\n\n\n\n","category":"module"},{"location":"api/#AlgebraicPetri.SchLabelledPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchLabelledPetriNet","text":"ACSet definition for a Petri net with labels on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchLabelledReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchLabelledReactionNet","text":"ACSet definition for a ReactionNet with labels on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPetriNet","text":"ACSet definition for a Petri net.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyLabelledPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyLabelledPetriNet","text":"ACSet definition for a LabelledPetriNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyLabelledReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyLabelledReactionNet","text":"ACSet definition for a LabelledReactionNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyPetriNet","text":"ACSet definition for a PetriNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyReactionNet","text":"ACSet definition for a ReactionNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchReactionNet","text":"ACSet definition for a Petri net with rates on transitions and concentrations on states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.AbstractPetriNet","page":"Library Reference","title":"AlgebraicPetri.AbstractPetriNet","text":"Abstract type for C-sets that contain a petri net.\n\nThis type encompasses C-sets where the schema for graphs is a subcategory of C. This includes, for example, graphs, symmetric graphs, and reflexive graphs, but not half-edge graphs.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicPetri.AbstractPropertyPetriNet","page":"Library Reference","title":"AlgebraicPetri.AbstractPropertyPetriNet","text":"Abstract Type for any PetriNet ACSet with  properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicPetri.LabelledPetriNet-Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}","page":"Library Reference","title":"AlgebraicPetri.LabelledPetriNet","text":"LabelledPetriNet(n, ts::Vararg{Union{Pair,Tuple}})\n\nConstructs a LabelledPetriNet object with state names as elements of n and labelled transitions described by ts. Transitions are given as transition_name=>((input_states)=>(output_states)).\n\nA LabelledPetriNet modelling the SIR model with 3 states and 2 transitions can be constructed as follows:\n\nLabelledPetriNet([:S, :I, :R], :inf=>((:S,:I)=>(:I,:I)), :rec=>(:I=>:R))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.LabelledReactionNet-Union{Tuple{C}, Tuple{R}, Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}} where {R, C}","page":"Library Reference","title":"AlgebraicPetri.LabelledReactionNet","text":"LabelledReactionNet{R,C}(n, ts::Vararg{Union{Pair,Tuple}}) where {R,C}\n\nConstructs a LabelledReactionNet object with labelled state concentrations as elements of n and labelled transitions described by ts. R is the data type used to store rates and C is the data type used to store concentrations.\n\nTransitions are given as (t_name=>t_rate)=>((input_states)=>(output_states)).\n\nA LabelledReactionNet modelling the SIR model with 3 states and 2 transitions, an initial population of 10 susceptible, 1 infected, 0 recovered and an infection rate of 0.5 and recovery rate of 0.1 can be constructed as follows:\n\nLabelledReactionNet{Float64, Float64}([:S=>10,:I=>1,:R=>0], (:inf=>0.5)=>((:S,:I)=>(:I,:I)), (:rec=>0.1)=>(:I=>:R))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ReactionNet-Union{Tuple{C}, Tuple{R}, Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}} where {R, C}","page":"Library Reference","title":"AlgebraicPetri.ReactionNet","text":"ReactionNet{R,C}(n, ts::Vararg{Union{Pair,Tuple}}) where {R,C}\n\nConstructs a ReactionNet object with state concentrations as elements of n and transitions described by ts. R is the data type used to store rates and C is the data type used to store concentrations.\n\nTransitions are given as transition_rate=>((input_states)=>(output_states)).\n\nA ReactionNet modelling the SIR model with 3 states and 2 transitions, an initial population of 10 susceptible, 1 infected, 0 recovered and an infection rate of 0.5 and recovery rate of 0.1 can be constructed as follows:\n\nReactionNet{Float64, Float64}([10,1,0], 0.5=>((1,2)=>(2,2)), 0.1=>(2=>3))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TransitionMatrices","page":"Library Reference","title":"AlgebraicPetri.TransitionMatrices","text":"TransitionMatrices\n\nThis data structure stores the transition matrix of an AbstractPetriNet object. This is primarily used for constructing the vectorfield representation of the Petri net.\n\n\n\n\n\n","category":"type"},{"location":"api/#Core.Type-Union{Tuple{AbstractPetriNet}, Tuple{T}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(pn::AbstractPetriNet)\n\nCast one type of AbstractPetriNet to another. Any unrepresented parts will be nothing.\n\npn = PetriNet(3, (1,2)=>(2,2), 2=>3)\nlabelled_pn = LabelledPetriNet(pn)\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{TransitionMatrices}, Tuple{T}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(tm::TransitionMatrices)\n\nConstruct any AbstractPetriNet from a given transition matrice representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{T}, Tuple{AbstractPetriNet, Any, Any}} where T<:AbstractPropertyPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPropertyPetriNet)(pn::AbstractPetriNet, sprops, tprops)\n\nAdd properties to the states and transitions of a given Petri Net.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{T}, Tuple{Int64, Vararg{Union{Tuple, Pair}}}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(n::Int, ts::Vararg{Union{Pair,Tuple}})\n\nConstructs any AbstractPetriNet object with n states and transitions described by ts. Transitions are given as (input_states)=>(output_states).\n\nA PetriNet modelling the SIR model with 3 states and 2 transitions can be constructed as follows:\n\nPetriNet(3, (1,2)=>(2,2), 2=>3)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{AbstractPetriNet, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(p::AbstractPetriNet, legs...)\n\nGenerates on OpenPetriNet with legs bundled as described by legs\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(p::AbstractPetriNet)\n\nConverts a PetriNet to an OpenPetriNet where each state is exposed as a leg of the cospan. The OpenPetriNet can be composed over an undirected wiring diagram (see this blog post for a description of this compositional tooling)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{Any, AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(n, p::AbstractPetriNet, m)\n\nGenerates on OpenPetriNet with two legs, n and m\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_input!-Tuple{AbstractPetriNet, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_input!","text":"add_input!(p::AbstractPetriNet,t,s;kw...)\n\nAdd an input relationship to the Petri net between the transition t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_inputs!-Tuple{AbstractPetriNet, Any, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_inputs!","text":"add_inputs!(p::AbstractPetriNet,n,t,s;kw...)\n\nAdd input relationships to the Petri net between the transitions t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_output!-Tuple{AbstractPetriNet, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_output!","text":"add_output!(p::AbstractPetriNet,t,s;kw...)\n\nAdd an output relationship to the Petri net between the transition t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_outputs!-Tuple{AbstractPetriNet, Any, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_outputs!","text":"add_outputs!(p::AbstractPetriNet,n,t,s;kw...)\n\nAdd output relationships to the Petri net between the transitions t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_species!-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.add_species!","text":"Add n species to the Petri net. Label and concentration can be provided depending on the kind of Petri net.\n\nReturns the ID of the species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_species!-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.add_species!","text":"Add a species to the Petri net. Label and concentration can be provided depending on the kind of Petri net.\n\nReturns the ID of the species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_transition!-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.add_transition!","text":"Add a transition to the Petri net. Label and rate can be provided depending on the kind of Petri net.\n\nReturns the ID of the transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_transitions!-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.add_transitions!","text":"Add n transitions to the Petri net. Label and rate can be provided depending on the kind of Petri net.\n\nReturns the ID of the transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.concentration-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.concentration","text":"Concentration of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.concentrations-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.concentrations","text":"All concentrations of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.flatten_labels-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.flatten_labels","text":"flatten_labels(pn::AbstractPetriNet)\n\nTakes a labelled Petri net or reaction net and flattens arbitrarily nested labels on the species and the transitions to a single symbol who's previously nested parts are separated by _.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.inputs-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.inputs","text":"Input relationships for a transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ni-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.ni","text":"Number of input relationships in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.no-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.no","text":"Number of output relationships in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ns-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.ns","text":"Number of states in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.nt-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.nt","text":"Number of transitions in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.outputs-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.outputs","text":"Output relationships for a transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.rate-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.rate","text":"Rate of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.rates-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.rates","text":"All rates of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sname-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.sname","text":"Name of species\n\nNote that this returns an index if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.snames-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.snames","text":"Names of species in  a Petri net\n\nNote that this returns indices if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sprop-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.sprop","text":"Property of species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sprops-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.sprops","text":"Properties of all species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tname-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.tname","text":"Name of transition\n\nNote that this returns an index if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tnames-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.tnames","text":"Names of transitions in  a Petri net\n\nNote that this returns indices if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tprop-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.tprop","text":"Property of transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tprops-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.tprops","text":"Properties of all transitions\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.vectorfield-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.vectorfield","text":"vectorfield(pn::AbstractPetriNet)\n\nGenerates a Julia function which calculates the vectorfield of the Petri net being simulated under the law of mass action.\n\nThe resulting function has a signature of the form f!(du, u, p, t) and can be passed to the DifferentialEquations.jl solver package.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.vectorfield_expr-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.vectorfield_expr","text":"vectorfield_expr(pn::AbstractPetriNet)\n\nGenerates a Julia expression which is then evaluated that  calculates the  vectorfield of the Petri net being simulated under the law of mass action.\n\nThe resulting function has a signature of the form f!(du, u, p, t) and can be passed to the DifferentialEquations.jl solver package.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.BilayerNetworks","page":"Library Reference","title":"AlgebraicPetri.BilayerNetworks","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri.BilayerNetworks]","category":"page"},{"location":"api/#AlgebraicPetri.Epidemiology","page":"Library Reference","title":"AlgebraicPetri.Epidemiology","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri.Epidemiology]","category":"page"},{"location":"api/#AlgebraicPetri.Epidemiology","page":"Library Reference","title":"AlgebraicPetri.Epidemiology","text":"Specific generators and useful tools for constructing epidemiological systems\n\n\n\n\n\n","category":"module"},{"location":"api/#AlgebraicPetri.Epidemiology.death","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.death","text":"LabelledPetriNet which describes the death process which moves tokens from I to D\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.exposure","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.exposure","text":"LabelledPetriNet which describes the exposure process where tokens in I \"expose\" tokens in S, changing them from S to E\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.illness","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.illness","text":"LabelledPetriNet which describes the illness process which moves tokens from E to I.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.infection","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.infection","text":"LabelledPetriNet which describes the infection process of tokens in state S by tokens in state I\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.recovery","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.recovery","text":"LabelledPetriNet which describes the recovery process which moves tokens from I to R\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.exposure_petri-NTuple{4, Symbol}","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.exposure_petri","text":"Generates an OpenLabelledPetriNet containing a single transition transition which takes as input a single token from place x and y and produces a single token in place z and y.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Epidemiology.oapply_epi-Tuple{Any, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.oapply_epi","text":"oapply_epi(ex, args...)\n\nGenerates a LabelledPetriNet under a composition pattern described by the undirected wiring diagram ex. This requires that the boxes in ex are only labelled with labels from the following set:\n\n[:infection, :exposure, :illness, :recovery, :death]\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Epidemiology.spontaneous_petri-Tuple{Symbol, Symbol, Symbol}","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.spontaneous_petri","text":"Generates an OpenLabelledPetriNet containing a single transition z that moves a token from place x to place y\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ModelComparison","page":"Library Reference","title":"AlgebraicPetri.ModelComparison","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri.ModelComparison]","category":"page"},{"location":"api/#AlgebraicPetri.ModelComparison.compare-Union{Tuple{T}, Tuple{T, Vararg{T}}} where T<:AbstractPetriNet","page":"Library Reference","title":"AlgebraicPetri.ModelComparison.compare","text":"compare Calculates all homomorphisms from a single Petri net (apex) to other Petri nets. This is returned as a Multispan with apex as the apex and the homomorphisms as the legs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ModelComparison.petri_homomorphisms-Tuple{AbstractPetriNet, AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.ModelComparison.petri_homomorphisms","text":"petri_homomorphisms Calculates all homomorphisms between two PetriNet models and returns an array of ACSetTransformations that describe these homomorphisms.\n\nNOTE: This function does restrict to homomorphisms which preserve the transition signatures (number of input/output wires).\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri.OpenTransitions]","category":"page"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{AbstractPetriNet, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(p::AbstractPetriNet, legs...)\n\nGenerates on OpenPetriNetT with legs bundled as described by legs\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(p::AbstractPetriNet)\n\nConverts a PetriNet to an OpenPetriNetT where each transition is exposed as a leg of the cospan. The OpenPetriNetT can be composed over an undirected wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{Any, AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(n, p::AbstractPetriNet, m)\n\nGenerates on OpenPetriNetT with two legs, n and m\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri","page":"Library Reference","title":"AlgebraicPetri.TypedPetri","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri.TypedPetri]","category":"page"},{"location":"api/#AlgebraicPetri.TypedPetri.add_reflexives-Tuple{Catlab.CategoricalAlgebra.CSets.ACSetTransformation, Any, AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.add_reflexives","text":"Modify a typed petri net to add \"reflexive transitions\". These are transitions which go from one species to itself, so they don't change the mass action semantics, but they are important for stratification.\n\nThe idea behind this is similar to the fact that the product of the graph –– with itself is\n\n\n/  / /\n\n/\n\n\n\nOne needs to add self-edges to each of the vertices in –– to get\n\n–– |   /| |  / | | /  | |/   | ––\n\nExample:\n\nadd_reflexives(sird_typed, [[:strata], [:strata], [:strata], []], infectious_ontology)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.oapply_typed-Tuple{LabelledPetriNet, Any, Vector{Symbol}}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.oapply_typed","text":"Takes in a labelled petri net and an undirected wiring diagram, where each of the boxes is labeled by a symbol that matches the label of a transition in the petri net. Then produces a petri net given by colimiting the transitions together, and returns the ACSetTransformation from that Petri net to the type system.\n\nThe tnames argument renames the transitions in the resulting typed Petri net.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.pairwise_id_petri-Tuple{AbstractVector{Symbol}}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.pairwise_id_petri","text":"Make Petri net with 'identity' transformation between all species pairs.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.pairwise_id_typed_petri-Tuple{Any, Any, Any, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.pairwise_id_typed_petri","text":"Make typed Petri net with 'identity' transformation between species pairs.\n\nAssumes a single species type and a single transition type. For each pair of places, generate a transition consuming 1 input for each place and producing 1 output in each place.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.prim_cospan-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.prim_cospan","text":"Produces the structured cospan of the transition over different species.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.prim_petri-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.prim_petri","text":"Takes in a petri net and a transition in that petri net, constructs a petri net with just that transition, returns the acsettransformation from that into the type system.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TypedPetri.typed_product-Tuple{Any, Any}","page":"Library Reference","title":"AlgebraicPetri.TypedPetri.typed_product","text":"This takes the \"typed product\" of two typed Petri nets p1 and p2, which has\n\na species for every pair of a species in p1 and a species in p2 with the same type\na transition for every pair of a transitions in p1 and a species in p2 with the same type\n\nThis is the \"workhorse\" of stratification; this is what actually does the stratification, though you may have to \"prepare\" the petri nets first with add_reflexives\n\nReturns a typed model, i.e. a map in Petri.\n\n\n\n\n\n","category":"method"},{"location":"api/#Package-Extensions","page":"Library Reference","title":"Package Extensions","text":"","category":"section"},{"location":"api/#[Catalyst.jl](https://github.com/SciML/Catalyst.jl)","page":"Library Reference","title":"Catalyst.jl","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Catalyst.ReactionSystem","category":"page"},{"location":"api/#Catalyst.ReactionSystem","page":"Library Reference","title":"Catalyst.ReactionSystem","text":"ReactionSystem(pn::AbstractPetriNet)\n\nConvert a general PetriNet to a ReactionSystem This conversion forgets any labels or rates provided, and converts all parameters and variables into symbols. It does preserve the ordering of transitions and states though (Transition 1 has a rate of k[1], state 1 has a concentration of S[1])\n\n\n\n\n\n","category":"type"},{"location":"api/#[ModelngToolkit.jl](https://github.com/SciML/ModelingToolkit.jl)","page":"Library Reference","title":"ModelngToolkit.jl","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"ModelingToolkit.ODESystem","category":"page"},{"location":"api/#ModelingToolkit.ODESystem","page":"Library Reference","title":"ModelingToolkit.ODESystem","text":"ODESystem(p::AbstractPetriNet; name=:PetriNet, kws...)\n\nConvert a general PetriNet to an ODESystem This conversion forgets any labels or rates provided, and converts all parameters and variables into symbols. It does preserve the ordering of transitions and states though (Transition 1 has a rate of k[1], state 1 has a concentration of S[1])\n\n\n\n\n\nODESystem(bn::Union{AbstractLabelledBilayerNetwork,AbstractBilayerNetwork}; name=:BilayerNetwork, simplify = false)\n\nConvert a general Bilayer Network to an ODESystem This conversion forgets any labels or rates provided, and converts all parameters and variables into symbols. It does preserve the ordering of transitions and states though (Transition 1 has a rate of k[1], state 1 has a concentration of S[1]). Note that symbolic simplification is not enable by default to preserve the bilayer structure. This is useful when one wants to convert symbolic expressions back to a bilayer network.\n\n\n\n\n\n","category":"type"},{"location":"api/#[OrdinaryDiffEq.jl](https://github.com/SciML/OrdinaryDiffEq.jl)","page":"Library Reference","title":"OrdinaryDiffEq.jl","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"OrdinaryDiffEq.ODEProblem","category":"page"},{"location":"api/#SciMLBase.ODEProblem","page":"Library Reference","title":"SciMLBase.ODEProblem","text":"ODEProblem(m::AbstractPetriNet, u0, tspan, β)\n\nConvert a general PetriNet to an ODEProblem This takes the initial conditions and rates as parameters and will ignore any initial conditions and rates embedded in the Petri Net if they exist.\n\n\n\n\n\nODEProblem(m::AbstractPetriNet, tspan)\n\nConvert a general PetriNet to an ODEProblem This assumes the concentrations and weights are embedded in the Petri Net.\n\n\n\n\n\n","category":"type"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"EditURL = \"../../../literate/enzymes/enzyme_reactions.jl\"","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#enzyme_example","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"(Image: )","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"using AlgebraicPetri\nusing Catlab.Programs\nusing Catlab.Graphics\nusing Catlab.WiringDiagrams\nusing Catlab.CategoricalAlgebra\n\nusing DifferentialEquations\nusing Plots\n\ndisplay_uwd(ex, prog=\"neato\") = to_graphviz(ex, box_labels=:name, junction_labels=:variable, graph_attrs=Dict(:overlap => \"false\"), prog=prog)\node(x, t) = ODEProblem(vectorfield(x), concentrations(x), t, rates(x));\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Define-objects-and-initial-conditions","page":"Cathepsin Enzyme Reactions","title":"Define objects and initial conditions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"ob(x) = codom(Open([first(x)], LabelledReactionNet{Number,Int}([x]), [first(x)])).ob;\nK = :K=>33000;\nS = :S=>33000;\nL = :L=>33000;\nKinact = :Kinact=>0;\nSinact = :Sinact=>0;\nLinact = :Linact=>0;\nE = :E=>700000;\nG = :G=>1300000;\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Helper-functions-for-generating-primitive-Petri-net-operations","page":"Cathepsin Enzyme Reactions","title":"Helper functions for generating primitive Petri net operations","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"inact(in,on::Number) = begin\n  inact = Symbol(first(in), :inact)\n  Open(LabelledReactionNet{Number,Int}(unique((in, inact=>0)), ((Symbol(:inact_,first(in)),on),first(in)=>inact)))\nend;\n\nbind(in1, in2, on::Number, off::Number) = begin\n  out = Symbol(first(in1),first(in2))\n  Open(LabelledReactionNet{Number,Int}(unique((in1, in2,out=>0)), ((Symbol(:bind_,first(in1),first(in2)),on),(first(in1),first(in2))=>out),\n                                                           ((Symbol(:unbind_,out),off),out=>(first(in1),first(in2)))))\nend;\n\ndeg(prod1,prod2,on::Number) = begin\n  in = Symbol(first(prod1),first(prod2))\n  prod2str = String(first(prod2))\n  degprod2 = Symbol(endswith(prod2str, \"inact\") ? first(prod2str) : prod2str, :deg)\n  Open(LabelledReactionNet{Number,Int}(unique((in=>0, prod1,degprod2=>0)), ((Symbol(:deg_,in),on),in=>(first(prod1),degprod2))));\nend;\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-itself","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with itself","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catX = @relation (X, Xinact, Xdeg) where (X, Xinact, Xdeg, XX, XXinact) begin\n  inactX(X, Xinact)\n  bindXX(X, XX)\n  degXX(XX, X, Xdeg)\n  bindXXinact(X, Xinact, XXinact)\n  degXXinact(XXinact, X, Xdeg)\nend\ndisplay_uwd(catX)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-Substrate-*Y*","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with Substrate Y","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catXsubY = @relation (X, Xinact, Xdeg, Y, Ydeg) where (X, Xinact, Xdeg, Y, XY, Ydeg) begin\n  bindXY(X, Y, XY)\n  degXY(XY, X, Ydeg)\nend\ndisplay_uwd(catXsubY)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-Cathepsin-*Y*","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with Cathepsin Y","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catXY = @relation (X, Xinact, Xdeg, Y, Yinact, Ydeg) where (X, Xinact, Xdeg, Y, Yinact, Ydeg, XY, XYinact) begin\n  bindXY(X, Y, XY)\n  degXY(XY, X, Ydeg)\n  bindXYinact(X, Yinact, XYinact)\n  degXYinact(XYinact, X, Ydeg)\nend\ndisplay_uwd(catXY)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Define-all-enzyme-reactions","page":"Cathepsin Enzyme Reactions","title":"Define all enzyme reactions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"rxns = Dict(\n  :K => [inact(K, 7.494e-10)\n         bind(K, K, 7.814e-4, 3.867e-3)\n         deg(K, K, 2.265e-1)\n         bind(K, Kinact, 7.814e-4, 3.867e-3)\n         deg(K, Kinact, 2.265e-1)],\n  :S => [inact(S, 7.494e-10)\n         bind(S, S, 7.814e-4, 3.867e-3)\n         deg(S, S, 2.265e-1)\n         bind(S, Sinact, 7.814e-4, 3.867e-3)\n         deg(S, Sinact, 2.265e-1)],\n  :L => [inact(L, 7.494e-10)\n         bind(L, L, 7.814e-4, 3.867e-3)\n         deg(L, L, 2.265e-1)\n         bind(L, Linact, 7.814e-4, 3.867e-3)\n         deg(L, Linact, 2.265e-1)],\n  :KE => [bind(K, E, 9.668e-6, 1e-2)\n          deg(K, E, 1.728e0)],\n  :KG => [bind(K, G, 2.764e-6, 8.78e-1)\n          deg(K, G, 1.502)],\n  :SE => [bind(S, E, 4.197e-7, 1.06e-3)\n          deg(S, E, 1.384e4)],\n  :SG => [bind(S, G, 5.152e-8, 3.894e-3)\n          deg(S, G, 8.755e-1)],\n  :LE => [bind(L, E, 1.977e-8, 1e-2)\n          deg(L, E, 1.066e2)],\n  :LG => [bind(L, G, 3.394e-8, 2.365e1)\n          deg(L, G, 4.352)],\n  :KS => [bind(K, S, 8.822e-4, 4.114e5)\n          deg(K, S, 9e-10)\n          bind(K, Sinact, 8.822e-4, 4.114e5)\n          deg(K, Sinact, 9e-10)],\n  :KL => [bind(K, L, 1.756e-4, 3.729e4)\n          deg(K, L, 6.505e6)\n          bind(K, Linact, 1.756e-4, 3.729e4)\n          deg(K, Linact, 6.505e6)],\n  :SK => [bind(S, K, 8.822e-4, 4.114e5)\n          deg(S, K, 9e-10)\n          bind(S, Kinact, 8.822e-4, 4.114e5)\n          deg(S, Kinact, 9e-10)],\n  :SL => [bind(S, L, 1e-3, 5e2)\n          deg(S, L, 1e-7)\n          bind(S, Linact, 1e-3, 5e2)\n          deg(S, Linact, 1e-7)],\n  :LK => [bind(L, K, 1e-3, 4.118e3)\n          deg(L, K, 3.234e1)\n          bind(L, Kinact, 1e-3, 4.118e3)\n          deg(L, Kinact, 3.234e1)],\n  :LS => [bind(L, S, 1.056e-12, 5e2)\n          deg(L, S, 5e-1)\n          bind(L, Sinact, 1.056e-12, 5e2)\n          deg(L, Sinact, 5e-1)]\n);\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Helper-functions-to-generate-oapply-calls","page":"Cathepsin Enzyme Reactions","title":"Helper functions to generate oapply calls","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"cat(cat) = begin\n  catsym = first(cat)\n  out = oapply(catX, Dict([:inactX, :bindXX, :degXX, :bindXXinact, :degXXinact] .=> rxns[catsym]), Dict(\n    :X=>ob(cat),\n    :Xinact=>ob(Symbol(catsym,:inact)=>0),\n    :Xdeg=>ob(Symbol(catsym,:deg)=>0),\n    :XX=>ob(Symbol(catsym,catsym)=>0),\n    :XXinact=>ob(Symbol(catsym,catsym,:inact)=>0)))\n  bundle_legs(out, [[1,2,3]])\nend\n\ncat_sub(cat1, sub) = begin\n  catsym = first(cat1)\n  subsym = first(sub)\n  catsub = Symbol(catsym, subsym)\n  out = oapply(catXsubY, Dict([:bindXY, :degXY] .=> rxns[catsub]), Dict(\n    :X=>ob(cat1),\n    :Xinact=>ob(Symbol(catsym,:inact)=>0),\n    :Xdeg=>ob(Symbol(catsym,:deg)=>0),\n    :Y=>ob(sub),\n    :XY=>ob(Symbol(catsym,subsym)=>0),\n    :Ydeg=>ob(Symbol(subsym,:deg)=>0)))\n  bundle_legs(out, [[1,2,3], [4,5]])\nend\n\n\ncat_cat(cat1, cat2) = begin\n  cat1sym = first(cat1)\n  cat2sym = first(cat2)\n  catcat = Symbol(cat1sym, cat2sym)\n  out = oapply(catXY, Dict([:bindXY, :degXY, :bindXYinact, :degXYinact] .=> rxns[catcat]), Dict(\n    :X=>ob(cat1),\n    :Xinact=>ob(Symbol(cat1sym,:inact)=>0),\n    :Xdeg=>ob(Symbol(cat1sym,:deg)=>0),\n    :Y=>ob(cat2),\n    :Yinact=>ob(Symbol(cat2sym,:inact)=>0),\n    :Ydeg=>ob(Symbol(cat2sym,:deg)=>0),\n    :XY=>ob(catcat=>0),\n    :XYinact=>ob(Symbol(catcat,:inact)=>0)))\n  bundle_legs(out, [[1,2,3], [4,5,6]])\nend\n\nfunctor(x) = oapply(x, Dict(\n  :catK=>cat(K),\n  :catS=>cat(S),\n  :catL=>cat(L),\n  :catKcatS=>cat_cat(K,S),\n  :catKcatL=>cat_cat(K,L),\n  :catScatK=>cat_cat(S,K),\n  :catScatL=>cat_cat(S,L),\n  :catLcatK=>cat_cat(L,K),\n  :catLcatS=>cat_cat(L,S),\n  :catKsubE=>cat_sub(K,E),\n  :catSsubE=>cat_sub(S,E),\n  :catLsubE=>cat_sub(L,E),\n  :catKsubG=>cat_sub(K,G),\n  :catSsubG=>cat_sub(S,G),\n  :catLsubG=>cat_sub(L,G)));\n\nfunction enzyme_uwd(enzymes::Array{Symbol}, substrates::Array{Symbol})\n  rel = RelationDiagram(0)\n\n  chemicals = vcat(substrates, enzymes)\n\n  subs = add_junctions!(rel, length(substrates), variable=substrates)\n  enzs = add_junctions!(rel, length(enzymes), variable=enzymes)\n  nsubs = length(subs)\n  nenzs = length(enzs)\n\n  catx = add_parts!(rel, :Box, nenzs, name=[Symbol(\"cat$i\") for i in enzymes])\n  add_parts!(rel, :Port, nenzs, junction=enzs, box=catx)\n\n  for x in 1:nenzs\n    for y in 1:nenzs\n      if y != x\n        catxy = add_part!(rel, :Box, name=Symbol(\"cat$(enzymes[x])cat$(enzymes[y])\"))\n        add_parts!(rel, :Port, 2, junction=[enzs[x], enzs[y]], box=catxy)\n      end\n    end\n  end\n\n  for x in 1:nenzs\n    for y in 1:nsubs\n      catxy = add_part!(rel, :Box, name=Symbol(\"cat$(enzymes[x])sub$(substrates[y])\"))\n      add_parts!(rel, :Port, 2, junction=[enzs[x], subs[y]], box=catxy)\n    end\n  end\n  add_parts!(rel, :OuterPort, length(chemicals), outer_junction = vcat(subs, enzs))\n  rel\nend\n\nenzyme_reaction(args...) = enzyme_uwd(args...) |> functor |> apex","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Manually-Defining-Models","page":"Cathepsin Enzyme Reactions","title":"Manually Defining Models","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE = @relation (K, S, E) begin\n  catK(K)\n  catS(S)\n  catKcatS(K, S)\n  catScatK(S, K)\n  catKsubE(K, E)\n  catSsubE(S, E)\nend\ndisplay_uwd(KSE)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Defining-Models-using-API","page":"Cathepsin Enzyme Reactions","title":"Defining Models using API","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-Elastin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, Elastin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE = enzyme_uwd([:K, :S], [:E])\ndisplay_uwd(KSE)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE_petri = apex(functor(KSE))\node_prob = ode(KSE_petri, (0.0, 120.0))\nsol = solve(ode_prob)\n\nplot(sol)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, lw = 2, ylims = (0, 15000), xlims = (0, 30))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-CatL,-Elastin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, CatL, Elastin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSLE = enzyme_reaction([:K, :S, :L], [:E])\node_prob = ode(KSLE, (0.0,120.0))\nsol = solve(ode_prob)\nplot(sol, lw = 1, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, ylims = (0, 20000), xlims = (0, 30), lw = 2, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-CatL,-Elastin,-Gelatin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, CatL, Elastin, Gelatin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSLEG = enzyme_reaction([:K, :S, :L], [:E, :G])\node_prob = ode(KSLEG, (0.0,120.0))\nsol = solve(ode_prob)\nplot(sol, lw = 1, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, ylims = (0, 30000), xlims = (0, 50), lw = 2, size = (1066, 600))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"EditURL = \"../../../literate/epidemiology/stratification.jl\"","category":"page"},{"location":"generated/epidemiology/stratification/#epidemiology_stratification","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"(Image: )","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"using AlgebraicPetri, AlgebraicPetri.TypedPetri\nusing Catlab\nusing DisplayAs, Markdown\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\nnothing #hide","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"This tutorial describes typed Petri nets and model stratification. Model stratification is the process by which a submodel is replicated along some axis and the submodels are allowed to interact in some specified way (e.g.; age-structured models). Specifically, methods from the section \"Type systems for open Petri nets\" of [Libkind 2022] are presented, which should be consulted for more information.","category":"page"},{"location":"generated/epidemiology/stratification/#Typed-Petri-nets","page":"Stratification of Epidemiological Models","title":"Typed Petri nets","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"An important part of model stratification is making sure that when combining e.g.; a mode of ageing and a model of disease transmission, that spurious or erroneous states or transitions are not generated (for example, simultaneously ageing and becoming infected). Category theory provides a way to specify formal stratification schemes that will respect domain knowledge via a type system for Petri nets. A typed Petri net is a morphism (generalized function) from a Petri net to another, where the codomain Petri net represents the type system under consideration, given as phi P to P_type. The morphism does not need to be injective, that is, multiple places can be mapped to the same place (likewise for transitions, etc).","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"We denote the Petri net that defines a type system as P_type. Let's consider a very simple type system that will nonetheless be very useful for a class of models of directly transmitted diseases, called P_infectious. There is a single type of place (population) and three types of transitions. Infectious transitions require two inputs and produce two outputs. Disease transitions are those that move a single individual amongst disease classes (e.g.; from E to I). Strata transitions are those that move an individual amongst classes of the stratifying variable (e.g.; between age classes). Because all transitions in the generated (stratified Petri nets) must have a map into P_infectious, we already see that spurious transitions like our example earlier are excluded.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"const infectious_ontology = LabelledPetriNet(\n  [:Pop],\n  :infect => ((:Pop, :Pop) => (:Pop, :Pop)),\n  :disease => (:Pop => :Pop),\n  :strata => (:Pop => :Pop)\n)\n\nto_graphviz(infectious_ontology)","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Now that we have P_infectious, we define a SIRD model with that type system We start by defining an undirected wiring diagram (UWD) which represents the processes and states in the SIRD model; note that the name of each box corresponds to one of the transitions in P_infectious, and that we specify the types of the junctions as Pop in the where clause.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Next we use oapply_typed which produces a typed Petri net by composing transitions based on P_infectious. The first two arguments are the type Petri net and UWD, and the vector of symbols gives the names of the transitions in the new typed Petri net. We then add reflexive transitions typed as :strata to indicate which states can be stratified Here we add reflexive transitions to the susceptible, infected, and recovered populations but we leave out the dead population as no individuals entering that compartment may leave.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Calling to_graphviz on the resulting object will display phi  P to P_infectious. We could apply dom (domain) or codom (codomain) on the object to extract P or P_infectious, respectively.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"sird_uwd = @relation (S,I,R,D) where (S::Pop, I::Pop, R::Pop, D::Pop) begin\n  infect(S, I, I, I)\n  disease(I, R)\n  disease(I, D)\nend\n\nsird_model = oapply_typed(infectious_ontology, sird_uwd, [:infection, :recovery, :death])\nsird_model = add_reflexives(sird_model, [[:strata], [:strata], [:strata], []], infectious_ontology)\n\nto_graphviz(sird_model)","category":"page"},{"location":"generated/epidemiology/stratification/#Define-intervention-models","page":"Stratification of Epidemiological Models","title":"Define intervention models","text":"","category":"section"},{"location":"generated/epidemiology/stratification/#Masking-model","page":"Stratification of Epidemiological Models","title":"Masking model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Let's say we want to stratify the populations in the SIRD model by masking or non-masking; or, generally by any reversible behavioral change. To generate our stratification scheme, we begin with a UWD describing the strata levels we are interested in (Masked and UnMasked), and the transitions possible in each level. Note that we give transitions of type strata which allow masking or unmasking. Unmasked individuals may transmit disease to either masked or unmasked individuals, but masked persons cannot transmit disease.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"We again use oapply_typed to generate the stratification scheme phi^P^to P_infectious, adding reflexive disease transitions to the typed Petri net as changes in disease status may occur in either stratum.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"masking_uwd = @relation (M,UM) where (M::Pop, UM::Pop) begin\n  strata(M, UM)\n  strata(UM, M)\n  infect(M, UM, M, UM)\n  infect(UM, UM, UM, UM)\nend\nmask_model = oapply_typed(infectious_ontology, masking_uwd, [:unmask, :mask, :infect_um, :infect_uu])\nmask_model = add_reflexives(mask_model, [[:disease], [:disease]], infectious_ontology)\n\nto_graphviz(dom(mask_model))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"To generate the stratified SIRD model, we use typed_product. As described in [Libkind 2022], stratification of a model can be seen as a pullback of phi and phi^, or as a product in the slice category PetriP_type.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"typed_product(sird_model, mask_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/stratification/#Vaccine-model","page":"Stratification of Epidemiological Models","title":"Vaccine model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"By changing P^ slightly, we can generate a stratification scheme to model vaccination. In this case, the transition between strata is irreversible (non-leaky vaccine), infection may occur between any pair of individuals (imperfect protection), and change in disease state may occur in any strata.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"vax_uwd = @relation (UV,V) where (UV::Pop, V::Pop) begin\n  strata(UV, V)\n  infect(V, V, V, V)\n  infect(V, UV, V, UV)\n  infect(UV, V, UV, V)\n  infect(UV, UV, UV, UV)\nend\nvax_model = oapply_typed(infectious_ontology, vax_uwd, [:vax, :infect_vv, :infect_uv, :infect_vu, :infect_uu])\nvax_model = add_reflexives(vax_model, [[:disease], [:disease]], infectious_ontology)\n\nto_graphviz(dom(vax_model))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Once again, the typed product, or pullback gives the SIRD model stratified by vaccination.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"typed_product(sird_model, vax_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/stratification/#Mask-Vax-Model","page":"Stratification of Epidemiological Models","title":"Mask-Vax Model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"By using a more complicated UWD, we can have a model that combines masking and vaccination.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"mask_vax_uwd = @relation (UV_UM,UV_M,V_UM,V_M) where (UV_UM::Pop, UV_M::Pop, V_UM::Pop, V_M::Pop) begin\n  strata(UV_UM, UV_M)\n  strata(UV_M, UV_UM)\n  strata(V_UM, V_M)\n  strata(V_M, V_UM)\n  strata(UV_UM, V_UM)\n  strata(UV_M, V_M)\n  infect(V_UM, V_UM, V_UM, V_UM)\n  infect(V_UM, UV_UM, V_UM, UV_UM)\n  infect(UV_UM, V_UM, UV_UM, V_UM)\n  infect(UV_UM, UV_UM, UV_UM, UV_UM)\n  infect(V_M, V_UM, V_M, V_UM)\n  infect(V_M, UV_UM, V_M, UV_UM)\n  infect(UV_M, V_UM, UV_M, V_UM)\n  infect(UV_M, UV_UM, UV_M, UV_UM)\nend\nmask_vax_model = oapply_typed(\n  infectious_ontology,\n  mask_vax_uwd,\n  [:mask_uv, :unmask_uv, :mask_v, :unmask_v, :vax_um, :vax_m, :infect_um_vv, :infect_um_uv, :infect_um_vu, :infect_um_uu, :infect_m_vv, :infect_m_uv, :infect_m_vu, :infect_m_uu]\n)\nmask_vax_model = add_reflexives(mask_vax_model, [[:disease], [:disease], [:disease], [:disease]], infectious_ontology)\n\nto_graphviz(dom(mask_vax_model))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Stratify our SIRD model on this mask + vaccine model to get a model of SIRD with a vaccination rate and masking policies:","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"typed_product(sird_model, mask_vax_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/stratification/#Define-geographic-models","page":"Stratification of Epidemiological Models","title":"Define geographic models","text":"","category":"section"},{"location":"generated/epidemiology/stratification/#Flux-model-between-N-regions","page":"Stratification of Epidemiological Models","title":"Flux model between N regions","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"In many cases, it is not practical to construct by hand the composition diagram used to build a complex typed Petri net. Here we demonstrate how to use the imperative interface provided by Catlab to construct a UWD describing a model of a population spread out amongst N regions. Individuals can travel between regions, but disease transmission is only possible between individuals in the same region. This is known as a flux model because individuals have the same behavior, so that the model can correctly simulate net \"flux\" of individuals between regions but not specific travel patterns.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"function travel_model(n)\n  uwd = RelationDiagram(repeat([:Pop], n))\n  junctions = Dict(begin\n    variable = Symbol(\"Region$(i)\")\n    junction = add_junction!(uwd, :Pop, variable=variable)\n    set_junction!(uwd, port, junction, outer=true)\n    variable => junction\n  end for (i, port) in enumerate(ports(uwd, outer=true)))\n\n  pairs = filter(x -> first(x) != last(x), collect(Iterators.product(keys(junctions), keys(junctions))))\n  for pair in pairs\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:strata)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n\n  act = oapply_typed(infectious_ontology, uwd, [Symbol(\"$(a)_$(b)\") for (a, b) in pairs])\n  add_reflexives(act, repeat([[:infect, :disease]], n), infectious_ontology)\nend\n\nto_graphviz(dom(travel_model(2)))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Stratify our SIRD model on this travel model with two regions:","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"typed_product(sird_model, travel_model(2)) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/stratification/#Simple-Trip-model-between-N-regions","page":"Stratification of Epidemiological Models","title":"Simple Trip model between N regions","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"As explored in [Citron 2021], the flux model is not sufficient when individuals travel behavior differs by their home region. A simple extension is the \"simple trip model\". We build this model in two parts. First we develop a \"living model\" which classifies populations according to what place their home is. The function pairwise_id_typed_petri is used to generate the \"infection\" transitions between each pair of populations. Reflexive transitions are added for strata and disease state transitions.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"function living_model(n)\n  typed_living = pairwise_id_typed_petri(infectious_ontology, :Pop, :infect, [Symbol(\"Living$(i)\") for i in 1:n])\n  add_reflexives(typed_living, repeat([[:disease, :strata]], n), infectious_ontology)\nend\n\nto_graphviz(dom(living_model(2)))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Taking the typed product with the previous travel model will now stratify that model by living status.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"simple_trip_model = typed_product(travel_model(2), living_model(2))\nto_graphviz(dom(simple_trip_model))","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Stratify our SIRD model on this simple trip model between two regions:","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"typed_product(sird_model, simple_trip_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/stratification/#Model-stratification-and-performance","page":"Stratification of Epidemiological Models","title":"Model stratification and performance","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Here we investigate performance of stratified models. We first set up a simple helper function to connect the undirected wiring diagrams to our infectious disease type system and add the necessary reflexive transitions for stratification.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"function oapply_mira_model(uwd)\n  model = oapply_typed(infectious_ontology, uwd, [Symbol(\"t$(n)\") for n in 1:nboxes(uwd)])\n  add_reflexives(model, [repeat([[:strata]], njunctions(uwd)-3)..., [], [:strata],[]], infectious_ontology)\nend","category":"page"},{"location":"generated/epidemiology/stratification/#SIDARTHE-Model","page":"Stratification of Epidemiological Models","title":"SIDARTHE Model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"BIOMD0000000955_miranet","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"m1_model = (@relation (S,I,D,A,R,T,H,E) where (S::Pop, I::Pop, D::Pop, A::Pop, R::Pop, T::Pop, H::Pop, E::Pop) begin\n  infect(S, D, I, D)\n  infect(S, A, I, A)\n  infect(S, R, I, R)\n  infect(S, I, I, I)\n  disease(I, D)\n  disease(I, A)\n  disease(I, H)\n  disease(D, R)\n  disease(D, H)\n  disease(A, R)\n  disease(A, H)\n  disease(A, T)\n  disease(R, T)\n  disease(R, H)\n  disease(T, E)\n  disease(T, H)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m1_model))","category":"page"},{"location":"generated/epidemiology/stratification/#SEIAHRD-Model","page":"Stratification of Epidemiological Models","title":"SEIAHRD Model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"BIOMD0000000960_miranet","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"m2_model = (@relation (S,E,I,A,H,R,D) where (S::Pop, E::Pop, I::Pop, A::Pop, H::Pop, R::Pop, D::Pop) begin\n  infect(S, I, E, I)\n  infect(S, A, E, A)\n  infect(S, H, E, H)\n  disease(E, I)\n  disease(E, A)\n  disease(I, H)\n  disease(I, R)\n  disease(I, D)\n  disease(A, R)\n  disease(A, D)\n  disease(H, D)\n  disease(H, R)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m2_model))","category":"page"},{"location":"generated/epidemiology/stratification/#SEIuIrQRD-Model","page":"Stratification of Epidemiological Models","title":"SEIuIrQRD Model","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"BIOMD0000000983_miranet","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"m3_model = (@relation (S,E,Iu,Ir,Q,R,D) where (S::Pop, E::Pop, Iu::Pop, Ir::Pop, Q::Pop, R::Pop, D::Pop) begin\n  infect(S, Ir, E, Ir)\n  infect(S, Iu, E, Iu)\n  infect(S, Ir, Q, Ir)\n  infect(S, Iu, Q, Iu)\n  disease(Q, Ir)\n  disease(E, Ir)\n  disease(E, Iu)\n  disease(Ir, R)\n  disease(Iu, R)\n  disease(Q, S)\n  disease(Ir, D)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m3_model))","category":"page"},{"location":"generated/epidemiology/stratification/#Enumerating-stratified-models","page":"Stratification of Epidemiological Models","title":"Enumerating stratified models","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"Next we can take all of our epidemiology, intervention, and geography models and easily enumerate and calculate the models for every possible stratification combination and investigate the resulting models with some set number of regions for the geographic stratification models.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"num_rgns = 5\ndisease_models = [(\"SIRD\", sird_model), (\"SIDARTHE\", m1_model), (\"SEIAHRD\", m2_model), (\"SEIuIrQRD\", m3_model)]\npolicy_models = [nothing, (\"Vaccination\", vax_model), (\"Masking\", mask_model), (\"Masking + Vaccination\", mask_vax_model)]\ntravel_models = [nothing, (\"Travel\", travel_model(num_rgns)), (\"Simple Trip\", typed_product(travel_model(num_rgns), living_model(num_rgns)))]\n\ntable = [\"| Model | Intervention | Geography ($(num_rgns) regions) | # of States | # of Transitions |\",\"|:--|$(repeat(\":-:|\", 4))\"]\n\nfor pieces in Iterators.product(disease_models, policy_models, travel_models)\n  petri = typed_product(last.(collect(filter(x -> !isnothing(x), pieces)))) |> dom\n  push!(table, \"|$(join([isnothing(piece) ? \"N/A\" : first(piece) for piece in pieces],\"|\"))|$(ns(petri))|$(nt(petri))|\")\nend\n\nMarkdown.parse(join(table, \"\\n\")) |> DisplayAs.HTML","category":"page"},{"location":"generated/epidemiology/stratification/#Performance","page":"Stratification of Epidemiological Models","title":"Performance","text":"","category":"section"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"As we increase the number of regions in our geographic stratification models, the number of states and transitions increase polynomially which causes the execution time for calculating the final stratified model to also increase polynomially.","category":"page"},{"location":"generated/epidemiology/stratification/","page":"Stratification of Epidemiological Models","title":"Stratification of Epidemiological Models","text":"(Image: Runtime vs. Number of Georgraphic Regions)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"EditURL = \"../../../literate/other/bilayerconversion.jl\"","category":"page"},{"location":"generated/other/bilayerconversion/#bilayernetwork_example","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"","category":"section"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"(Image: )","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"using Pkg Pkg.status() Pkg.activate(\".\")","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Pkg.instantiate()","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Pkg.develop(path=\"../../\") Pkg.instantiate()","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"using AlgebraicPetri\nusing AlgebraicPetri.Epidemiology\nusing AlgebraicPetri.BilayerNetworks\n\nusing Catlab\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphics\nimport Catlab.CategoricalAlgebra: migrate!\nusing Catlab.WiringDiagrams\nusing Catlab.Programs.RelationalPrograms\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\n\nusing PrettyTables\nfunction printsoln(bn::AbstractLabelledBilayerNetwork, soln::Vector)\n    pretty_table(soln)\nend","category":"page"},{"location":"generated/other/bilayerconversion/#SIR-Model:","page":"Converting Models to Computation Graphs","title":"SIR Model:","text":"","category":"section"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"define model","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"sir = @relation (s,i,r) begin\n    infection(s,i)\n    recovery(i,r)\nend\ndisplay_uwd(sir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Extract the Petri network form of the model.","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"psir = apex(oapply_epi(sir))\npsir\nto_graphviz(psir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Convert the Petri network into a bilayer network and draw it. This model uses a computation graph to express the computation of the vector field of the Petri net.","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnsir = BilayerNetwork()\nmigrate!(bnsir, psir)\nbnsir\nto_graphviz(bnsir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"We can hand code a Bilayer netowork using the @acset macro provided by Catlab. As you can see from the code, there is a lot of typing to specify the incidence of all these wires. The Petri Net is more compact. This notion of Bilayer network comes from the definition of mass action kinetics for reaction networks.","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"hand coded Bilayer network","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnsir_test = @acset BilayerNetwork begin\n    Qin = 3\n    Qout = 3\n    Win = 3\n    Wa = 3\n    Wn = 3\n    Box = 2\n    arg = [1,2,2]\n    call = [1,1,2]\n    efflux = [1,1,2]\n    effusion = [1,2,2]\n    influx = [1,1,2]\n    infusion = [2,2,3]\nend\n\n@assert bnsir == bnsir_test\n\nfunction roundtrip(pn::AbstractPetriNet, bn::AbstractBilayerNetwork)\n    roundtrippetri = PetriNet()\n    migrate!(roundtrippetri, bn)\n    pn_structure = PetriNet()\n    copy_parts!(pn_structure, pn)\n    return roundtrippetri, pn_structure\nend","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"We can specify the SEIR model with the relation macro and functorial semantics as usual.","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"seir = @relation (s,e,i,r) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\nend\n\npseir = apex(oapply_epi(seir))","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"By converting this to a Bilayer network, we are able to visualize differences in the computational pattern of data flow between different reaction network models.","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnseir = BilayerNetwork()\nmigrate!(bnseir, pseir)\n\nbnrt,pnstr = roundtrip(pseir, bnseir)\n\ndisplay_uwd(sir)\n\nto_graphviz(psir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnsir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnseir)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnrt)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"qm = @relation (s,q) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    quarexp(e,q)\n    quarinf(i,q)\nend\ndisplay_uwd(qm)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.Epidemiology: exposure_petri, spontaneous_petri\nsemantics = Dict(\n    :infection => exposure_petri(:S, :I, :I, :inf),\n    :exposure  => exposure_petri(:S, :I, :E, :exp),\n    :illness   => spontaneous_petri(:E,:I,:ill),\n    :recovery  => spontaneous_petri(:I,:R,:rec),\n    :death     => spontaneous_petri(:I,:D,:death),\n    :quarexp   => spontaneous_petri(:E, :Q, :qe),\n    :quarinf   => spontaneous_petri(:I, :Q, :qi),\n    :quarrec   => spontaneous_petri(:Q, :R, :qr)\n)\npn_quar = oapply(qm, semantics)  |> apex\nto_graphviz(pn_quar)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnquar = LabelledBilayerNetwork()\nmigrate!(bnquar, pn_quar)\nto_graphviz(bnquar)\n\nqm = @relation (s,i,q) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    quarexp(e,q)\n    quarinf(i,q)\n    quarrec(q,r)\nend\ndisplay_uwd(qm)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"pn_quar = oapply(qm, semantics)  |> apex\nto_graphviz(pn_quar)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnquar = LabelledBilayerNetwork()\nmigrate!(bnquar, pn_quar)\nto_graphviz(bnquar)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"quarrt = LabelledPetriNet()\nmigrate!(quarrt, bnquar) |> to_graphviz\n\nbnquar","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.BilayerNetworks: evaluate!, evaluate\n\nbnsir = LabelledBilayerNetwork()\nmigrate!(bnsir, psir)\n\nevaluate(bnsir, [10.0, 1, 0.0], inf=0.1, rec=0.3)\n\nevaluate(bnquar, [10.0, 1, 0, 0,0,0], exp=0.1, rec=0.3, qi=0.2, ill=0.7, qe=0.23, qr=0.3)\n\nfunction euler(bn::AbstractLabelledBilayerNetwork, state, nsteps::Integer, stepsize::Real; params...)\n    #preallocate storage so that each step is nonallocating\n    #create a storage space for steps of euler's method store intermediate\n    #states as named tuples so that you can integrate with julia Tables.jl data  analysis ecosystem\n    du = zeros(length(state))\n    ϕ = ones(nparts(bn, :Box))\n    u = tuple(state...)\n    results = Vector{NamedTuple{tuple(bn[:,:variable]...)}}()\n    for i in 1:nsteps\n        u = u .+ stepsize.*evaluate!(du, ϕ, bn, u; params...)\n        push!(results, NamedTuple{tuple(bn[:,:variable]...)}(u))\n    end\n    return results\nend\n\nsoln = euler(bnquar, (S=10.0, I=1, E=0, R=0, Q=0), 30, 0.15, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)\nprintsoln(bnquar, soln)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.BilayerNetworks: compile\ncompile(bnquar, :du, :ϕ, :u, :p)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"compile(bnquar, :du, :ϕ, :u, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"function eulers(bn::AbstractLabelledBilayerNetwork, funcname::Symbol; params...)\n    f = compile(bn, :du, :ϕ, :u; params...)\n    varnames = tuple(bn[:,:variable]...)\n    nϕ = nparts(bn, :Box)\n    quote\n    function $funcname(state, nsteps::Integer, stepsize::Real)\n        $f\n        #preallocate storage so that each step is nonallocating\n        du = zeros(length(state))\n        ϕ = ones($nϕ)\n        u = tuple(state...)\n        #create a storage space for steps of euler's method\n        #store intermediate states as named tuples so that you can integrate\n        #with julia Tables.jl data analysis ecosystem\n        results = Vector{NamedTuple{$varnames}}()\n        for i in 1:nsteps\n            Δ = f!(du, ϕ, u, 0)\n            u = u .+ stepsize.*Δ\n            push!(results, NamedTuple{$varnames}(u))\n        end\n        return results\n    end\n    end\nend\n\neulers(bnsir, :eulsir, inf=0.3, rec=0.2)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eulseirqexp = eulers(bnquar, :eulseirq, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eulsirexp = eulers(bnsir, :eulsir, inf=0.3, rec=0.2)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eval(eulsirexp)\nsoln_codegen = eulsir((S=10.0, I=1, R=0), 30, 0.15)\npretty_table(soln_codegen)","category":"page"},{"location":"generated/other/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eval(eulseirqexp)\nsoln_codegen = eulseirq((S=10.0, I=1, E=0, R=0, Q=0), 30, 0.15)\npretty_table(soln_codegen)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"EditURL = \"../../../literate/epidemiology/composition.jl\"","category":"page"},{"location":"generated/epidemiology/composition/#epidemiology_basic","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"(Image: )","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"using AlgebraicPetri\nusing AlgebraicPetri.Epidemiology\n\nusing LabelledArrays\nusing OrdinaryDiffEq\nusing Plots\n\nusing Catlab\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\nnothing #hide","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"In this tutorial we introduce the basic concepts of modeling with open Petri nets (PN). Specifically, methods from the section \"Compositional methods of model specification\" of [Libkind 2022] are presented, which should be consulted for more information.","category":"page"},{"location":"generated/epidemiology/composition/#Petri-nets","page":"Composition of Epidemiological Models","title":"Petri nets","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Petri nets are a mathematical language to describe state transition systems which can effectively represent complex relationships between processes, such as parallelism, concurrency, dependency, and conflict. Originally developed for the design of digital systems, their extremely general formulation has made them useful for modeling in chemistry, biology, ecology, and epidemiology, among other domains. For more information, see the Wikipedia article.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"The type of Petri nets used in AlgebraicPetri are whole-grain Petri nets introduced by [Kock 2020]. Briefly, these Petri nets can be described by the following schema, where S is the set of places or species, T is the set of transitions, and I and O are the sets of input (transition to place) and output (place to transition) arcs. For a concrete instance of a Petri net, the labeled boxes in the diagram become sets, and arrows become functions, and such a data instance on a schema is known as a C-Set (or acset, for Attributed C-Set); please see Catlab.jl for more details.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"to_graphviz(SchPetriNet)","category":"page"},{"location":"generated/epidemiology/composition/#SIS-Model","page":"Composition of Epidemiological Models","title":"SIS Model","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"The susceptible-infectious-susceptible (SIS) model is one of the simplest models of mathematical epidemiology. Nonetheless it is a useful starting point to understand how to use PNs to express and build more complex epidemiological models.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"We first show how to build the SIS model directly. We use the LabelledPetriNet type which is an elaboration of the schema shown above which allows us to attach names to the places and transitions, for enhanced readability. The first argument gives the list of place names. Remaining arguments specify transitions. The first element of the pair type is the name of the transition. The second element is another pair whose first element gives the names of input species and second element is the names of output species. The to_graphviz method from Catlab displays the Petri net.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"si = LabelledPetriNet([:S, :I], :inf=>((:S,:I)=>(:I,:I)), :rec=>:I=>:S)\nto_graphviz(si)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Now we demonstrate how to use the category of open Petri nets to build the SIS model compositionally. While the additional complexity is superfluous for the SIS system, it is the simplest non-trivial system which demonstrates the concepts.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"An open Petri net is a Petri net where certain places are \"exposed\" as gluing points that can be joined with other systems, supporting a compositional style of modeling where a complex system can be broken down into interactions of more basic systems. Open Petri nets are a type of object called a \"structured multicospan\", which is an object containing the original Petri net S (\"apex\"), a list of finite sets A_1dotsA_n (\"feet\"), and functions A_1to SdotsA_nto S (\"legs\"). The legs specify the places in the apex Petri net where it may be joined to other systems.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"To generate the SIS model compositionally, we first make two open Petri nets, one containing the infection transition and the other containing the recovery transition. We can use the helper methods exposure_petri and spontaneous_petri from the Epidemiology module of AlgebraicPetri to quickly generate the open labelled Petri nets.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"si_inf = exposure_petri(:S, :I, :I, :inf);\nsi_rec = spontaneous_petri(:I, :S, :rec);\nnothing #hide","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"The resulting objects are structured multicospans, and by default, each place is exposed as a leg. Because each of these elementary Petri nets has only two distinct places, there are two legs. We can view the map into the apex from the first leg using Catlab's graphviz functionality:","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"to_graphviz(first(legs(si_inf)))","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Now we must specify a composition syntax describing how to glue together the open Petri nets to generate the composed system. Specifically, composition is described using an undirected wiring diagram (UWD), a graphical language for describing relations between objects. We can specify the UWD for the SIS system using the @relation macro from Catlab; the function-like syntax in the body are \"boxes\" and variables are \"junctions\". Generally, boxes represent processes which may consume or produce resources represented as junctions.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"To compose the open Petri nets, each box in the UWD will correspond to an open PN whose feet attach to the junctions that box is connected to. The composite PN is then constructed by gluing the component PNs along at the shared junctions (places).","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"si_uwd = @relation (s,i) begin\n    infection(s,i)\n    recovery(i,s)\nend\n\ndisplay_uwd(si_uwd)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"To produce the composite Petri net from our building blocks, the oapply method from Catlab performs the gluing. We provide the UWD as first argument and a dictionary mapping box names to open Petri nets as the second, and view the result.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"si = oapply(si_uwd, Dict(:infection=>si_inf, :recovery=>si_rec))\n\nto_graphviz(si)","category":"page"},{"location":"generated/epidemiology/composition/#SIR-Model","page":"Composition of Epidemiological Models","title":"SIR Model","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"The susceptible-infectious-recovered (SIR) model is another basic model of mathematical epidemiology.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"sir = @relation (s,i,r) begin\n    infection(s,i)\n    recovery(i,r)\nend\ndisplay_uwd(sir)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"To generate the SIR model as a Petri net, we use the helper function oapply_epi from the Epidemiology module of AlgebraicPetri, which has some definitions of common \"atomic\" Petri nets from epidemiological models. For more details, please see the documentation for that method.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"p_sir = apex(oapply_epi(sir))\nto_graphviz(p_sir)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Labelled vectors are used to create the initial state and reaction rate parameters for each transition.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"u0 = LVector(S=10, I=1, R=0);\np = LVector(inf=0.4, rec=0.4);\nnothing #hide","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"The vectorfield method interprets the PN as describing mass-action kinetics with a rate constant associated to each transition, which can be used to simulate ODEs associated to the PN.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"prob = ODEProblem(vectorfield(p_sir),u0,(0.0,7.5),p);\nsol = solve(prob,Tsit5())\n\nplot(sol, labels=[\"S\" \"I\" \"R\"])","category":"page"},{"location":"generated/epidemiology/composition/#SEIR-Model","page":"Composition of Epidemiological Models","title":"SEIR Model","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"For the susceptible-exposed-infectious-recovered (SEIR) model, we again define a UWD to describe composition syntax.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"seir = @relation (s,e,i,r) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\nend\ndisplay_uwd(seir)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"p_seir = apex(oapply_epi(seir))\nto_graphviz(p_seir)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Define initial states and transition rates, then create, solve, and visualize ODE problem:","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"u0 = LVector(S=10, E=1, I=0, R=0);\np = LVector(exp=.9, ill=.2, rec=.5);\n\nprob = ODEProblem(vectorfield(p_seir),u0,(0.0,15.0),p);\nsol = solve(prob,Tsit5())\n\nplot(sol, labels=[\"S\" \"E\" \"I\" \"R\"])","category":"page"},{"location":"generated/epidemiology/composition/#SEIRD-Model","page":"Composition of Epidemiological Models","title":"SEIRD Model","text":"","category":"section"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"We can add a deceased component and a death process to the SEIR model, specified with an undirected wiring diagram.","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"seird = @relation (s,e,i,r,d) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    death(i,d)\nend\ndisplay_uwd(seird)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"p_seird = apex(oapply_epi(seird))\nto_graphviz(p_seird)","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"Define initial states and transition rates, then create, solve, and visualize ODE problem:","category":"page"},{"location":"generated/epidemiology/composition/","page":"Composition of Epidemiological Models","title":"Composition of Epidemiological Models","text":"u0 = LVector(S=10, E=1, I=0, R=0, D=0);\np = LVector(exp=0.9, ill=0.2, rec=0.5, death=0.1);\n\nprob = ODEProblem(vectorfield(p_seird),u0,(0.0,15.0),p);\nsol = solve(prob,Tsit5())\n\nplot(sol, labels=[\"S\" \"E\" \"I\" \"R\" \"D\"])","category":"page"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"EditURL = \"../../../literate/other/max_common_subobject.jl\"","category":"page"},{"location":"generated/other/max_common_subobject/#max_common_subobject","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"(Image: )","category":"page"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"using AlgebraicPetri\nusing Catlab.CategoricalAlgebra, Catlab.Graphics","category":"page"},{"location":"generated/other/max_common_subobject/#Define-epidemiology-models","page":"Maximum Common Sub C-Set","title":"Define epidemiology models","text":"","category":"section"},{"location":"generated/other/max_common_subobject/#SIR","page":"Maximum Common Sub C-Set","title":"SIR","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"sir   = LabelledPetriNet([:S, :I, :R],\n                         :inf => ((:S, :I) => (:I, :I)),\n                         :rec => (:I => :R)\n                        )\nto_graphviz(sir)","category":"page"},{"location":"generated/other/max_common_subobject/#SIRD","page":"Maximum Common Sub C-Set","title":"SIRD","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"sird  = LabelledPetriNet([:S, :I, :R, :D],\n                         :inf => ((:S, :I) => (:I, :I)),\n                         :rec => (:I => :R),\n                         :death => (:R => :D)\n                        )\nto_graphviz(sird)","category":"page"},{"location":"generated/other/max_common_subobject/#SEIR","page":"Maximum Common Sub C-Set","title":"SEIR","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"seir  = LabelledPetriNet([:S, :E, :I, :R],\n                         :exp => ((:S, :I) => (:E, :I)),\n                         :ill => (:E => :I),\n                         :rec => (:I => :R)\n                        )\nto_graphviz(seir)","category":"page"},{"location":"generated/other/max_common_subobject/#SEIRD","page":"Maximum Common Sub C-Set","title":"SEIRD","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"seird = LabelledPetriNet([:S, :E, :I, :R, :D],\n                         :exp => ((:S, :I) => (:E, :I)),\n                         :ill => (:E => :I),\n                         :rec => (:I => :R),\n                         :death => (:R => :D)\n                        )\nto_graphviz(seird)","category":"page"},{"location":"generated/other/max_common_subobject/#Calculate-the-Maximum-Common-C-Set","page":"Maximum Common Sub C-Set","title":"Calculate the Maximum Common C-Set","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"sub, overlaps = maximum_common_subobject(sir, sird, seir, seird) |> first\nmorphisms = legs(overlaps[1])\n\nto_graphviz(sub)","category":"page"},{"location":"generated/other/max_common_subobject/#Visualize-Sub-C-Sets","page":"Maximum Common Sub C-Set","title":"Visualize Sub C-Sets","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"The morphism from each model to the maximum common C-Set is depicted in bold.","category":"page"},{"location":"generated/other/max_common_subobject/#SIR-2","page":"Maximum Common Sub C-Set","title":"SIR","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"morphisms[1](sub) |> to_graphviz","category":"page"},{"location":"generated/other/max_common_subobject/#SIRD-2","page":"Maximum Common Sub C-Set","title":"SIRD","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"morphisms[2](sub) |> to_graphviz","category":"page"},{"location":"generated/other/max_common_subobject/#SEIR-2","page":"Maximum Common Sub C-Set","title":"SEIR","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"morphisms[3](sub) |> to_graphviz","category":"page"},{"location":"generated/other/max_common_subobject/#SEIRD-2","page":"Maximum Common Sub C-Set","title":"SEIRD","text":"","category":"section"},{"location":"generated/other/max_common_subobject/","page":"Maximum Common Sub C-Set","title":"Maximum Common Sub C-Set","text":"morphisms[4](sub) |> to_graphviz","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"EditURL = \"../../../literate/epidemiology/disease_strains.jl\"","category":"page"},{"location":"generated/epidemiology/disease_strains/#epidemiology_strains","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"(Image: )","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"using AlgebraicPetri, AlgebraicPetri.TypedPetri\nusing Catlab.Programs, Catlab.Graphics\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing DisplayAs, Markdown","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"This example presents models incorporating multiple strains of disease and vaccine type. Importantly, it shows why stratification by disease strain is different from other stratifications, e.g. geography or age, and requires using a different type system. If you are unfamiliar with stratification, we recommend first reading the stratification tutorial.","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-basic-type-system","page":"Multiple-strain Disease Model with Vaccination","title":"Define basic type system","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We start by defining our basic type system, P_infectious for infectious disease models.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"const infectious_ontology = LabelledPetriNet(\n  [:Pop],\n  :infect => ((:Pop, :Pop) => (:Pop, :Pop)),\n  :disease => (:Pop => :Pop),\n  :strata => (:Pop => :Pop)\n)\n\nto_graphviz(infectious_ontology)","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We define a simple SIR model with reflexive transitions typed as \"strata\" to indicate which stratified states will interact with transitions amongst strata.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_uwd = @relation (S,I,R) where (S::Pop, I::Pop, R::Pop) begin\n  infect(S, I, I, I)\n  disease(I, R)\nend\n\nsir_model = oapply_typed(infectious_ontology, sir_uwd, [:infection, :recovery])\nsir_model = add_reflexives(sir_model, [[:strata], [:strata], [:strata]], infectious_ontology)\n\nto_graphviz(dom(sir_model))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-a-model-of-multiple-vaccine-types","page":"Multiple-strain Disease Model with Vaccination","title":"Define a model of multiple vaccine types","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We also define a model of vaccination with multiple vaccine types, typed over P_infectious. Each stratum has reflexive \"disease\" transitions. Transitions which represent the administration of a vaccine to an individual are typed as \"strata\". Infection transitions between individuals of different vaccination status is possible (i.e.; we do not assume a perfect vaccine).","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"function vax_model(n)\n  uwd = RelationDiagram(repeat([:Pop], n+1))\n\n  variable = :Unvaxxed\n  junction = add_junction!(uwd, :Pop, variable=variable)\n  port = ports(uwd, outer=true)[1]\n  set_junction!(uwd, port, junction, outer=true)\n  junctions = Dict(variable => junction)\n  for i in 1:n\n    variable = Symbol(\"VaxType$(i)\")\n    junction = add_junction!(uwd, :Pop, variable=variable)\n    port = ports(uwd, outer=true)[i+1]\n    set_junction!(uwd, port, junction, outer=true)\n    junctions[variable] = junction\n  end\n\n  strains = filter((x) -> x != Symbol(\"Unvaxxed\"), keys(junctions))\n  for s in strains\n    pair = (:Unvaxxed, s)\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:strata)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n  tnames = [Symbol(\"vax_$(b)\") for b in strains]\n\n  pairs = collect(Iterators.product(keys(junctions), keys(junctions)))\n  for pair in pairs\n    ins_outs = (pair[1], pair[2], pair[1], pair[2])\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in ins_outs], name=:infect)\n    for (rgn, port) in zip(ins_outs, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n    push!(tnames,Symbol(\"inf_$(pair[1])_$(pair[2])\"))\n  end\n  act = oapply_typed(infectious_ontology, uwd, tnames)\n  add_reflexives(act, repeat([[:disease]], n+1), infectious_ontology)\nend\n\nto_graphviz(dom(vax_model(2)))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Stratify-the-SIR-model-with-vaccinations-for-two-vaccine-types","page":"Multiple-strain Disease Model with Vaccination","title":"Stratify the SIR model with vaccinations for two vaccine types","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We can now stratify the two typed models to get a model of SIR with vaccination by multiple possible vaccine types.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"typed_product(sir_model, vax_model(2)) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-a-model-of-multiple-disease-strains","page":"Multiple-strain Disease Model with Vaccination","title":"Define a model of multiple disease strains","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"Here we define a model for multiple disease strains, typed by P_infectious. In this model, uninfected individuals can become infected by individuals carrying one of the strains. We add reflexive transitions of types :disease and :strata for the strain states but only :strata for the uninfected state, because those individuals should only correspond to S in the disease model.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"function strain_model′(n)\n  uwd = RelationDiagram(repeat([:Pop], n+1))\n  variable = :Uninfected\n  junction = add_junction!(uwd, :Pop, variable=variable)\n  port = ports(uwd, outer=true)[1]\n  set_junction!(uwd, port, junction, outer=true)\n  junctions = Dict(variable => junction)\n  for i in 1:n\n    variable = Symbol(\"Strain$(i)\")\n    junction = add_junction!(uwd, :Pop, variable=variable)\n    port = ports(uwd, outer=true)[i+1]\n    set_junction!(uwd, port, junction, outer=true)\n    junctions[variable] = junction\n  end\n  strains = filter((x) -> x != Symbol(\"Uninfected\"), keys(junctions))\n  for s in strains\n    pair = (:Uninfected, s, s, s)\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:infect)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n  act = oapply_typed(infectious_ontology, uwd, [Symbol(\"inf_$(b)\") for b in strains])\n  add_reflexives(act, vcat([[:strata]],repeat([[:disease,:strata]], n)), infectious_ontology)\nend\n\nto_graphviz(dom(strain_model′(2)))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Stratify-the-SIRD-model-for-two-strains","page":"Multiple-strain Disease Model with Vaccination","title":"Stratify the SIRD model for two strains","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"Unfortunately, stratification of these models does not produce the desired result, leading to many states and transitions. The problem is that it does not make sense for the uninfected population to be stratified over the full set of states of the SIRD model (i.e.; uninfected persons can never have any disease state other than \"S\"). This is due to the fact that there is only one type of place in P_infectious, so instead the pullback of places simply becomes the product.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We can address this by changing the type system to include multiple place types.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"typed_product(sir_model, strain_model′(2)) |> dom |> to_graphviz","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-a-new-type-system-and-corresponding-disease-and-multi-strain-models","page":"Multiple-strain Disease Model with Vaccination","title":"Define a new type system and corresponding disease and multi-strain models","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"The new type system has separate states for uninfected and infected to account for the asymmetry in their role in infection and for the corresponding asymmetry in the intended stratification. Accordingly, the :Inf state has :disease and :strataI transitions. The :Uninf state has a :strataU transition, but no :disease transition. We denote the new type system by P_strain.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"const strain_ontology = LabelledPetriNet(\n  [:Uninf, :Inf],\n  :infect => ((:Uninf, :Inf) => (:Inf, :Inf)),\n  :disease => (:Inf => :Inf),\n  :strataI => (:Inf => :Inf),\n  :strataU => (:Uninf => :Uninf)\n)\n\nto_graphviz(strain_ontology)","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We now recreate the SIR model using the new type system. Note that the where clause now specifies the differing place types for each state.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_for_strains_uwd = @relation (S,I,R) where (S::Uninf, I::Inf, R::Inf) begin\n  infect(S, I, I, I)\n  disease(I, R)\nend\nsir_for_strains_model = oapply_typed(strain_ontology, sir_for_strains_uwd, [:infection, :recovery])\nsir_for_strains_model = add_reflexives(sir_for_strains_model, [[:strataU], [:strataI], [:strataI]], strain_ontology)\n\nto_graphviz(sir_for_strains_model)","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"And similarly reform the multi-strain model.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"function strain_model(n)\n  uwd = RelationDiagram(vcat([:Uninf],repeat([:Inf], n)))\n  variable = :Uninfected\n  junction = add_junction!(uwd, :Uninf, variable=variable)\n  port = ports(uwd, outer=true)[1]\n  set_junction!(uwd, port, junction, outer=true)\n  junctions = Dict(variable => junction)\n  for i in 1:n\n    variable = Symbol(\"Strain$(i)\")\n    junction = add_junction!(uwd, :Inf, variable=variable)\n    port = ports(uwd, outer=true)[i+1]\n    set_junction!(uwd, port, junction, outer=true)\n    junctions[variable] = junction\n  end\n  strains = filter((x) -> x != Symbol(\"Uninfected\"), keys(junctions))\n  for s in strains\n    pair = (:Uninfected, s, s, s)\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:infect)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n  act = oapply_typed(strain_ontology, uwd, [Symbol(\"inf_$(b)\") for b in strains])\n  add_reflexives(act, vcat([[:strataU]],repeat([[:disease,:strataI]], n)), strain_ontology)\nend\n\nto_graphviz(strain_model(2))","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"When we now stratify we get the desired model. Note however that there are extraneous \"strata\" transitions; this is because there were no non-trivial stratum transitions in either input typed Petri net. (note that only \"disease\" and \"infect\" transition types were needed to fully define the multiple strain dynamics).","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain = typed_product(sir_for_strains_model, strain_model(2))\n\nto_graphviz(dom(sir_strain))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Post-composition:-Retyping-the-type-system","page":"Multiple-strain Disease Model with Vaccination","title":"Post-composition: Retyping the type system","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"In some instances, we may want to relate models typed to different type systems. For example, we usually type our simple_trip model of geographic regions to the infectious_ontology such that we can stratify a disease model by geographic regions, but the multi-strain disease model above is typed by the new strain_ontology.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"Crucially, we can accomplish this if there is an appropriate morphism (map) between the type systems because post-composition by a morphism of type systems is functorial. In this case, there is a morphism from strain_ontology to infectious_ontology (P_strain to P_infectious), so we will be able to \"switch\" type systems.","category":"page"},{"location":"generated/epidemiology/disease_strains/#Morphism-from-strain_ontology-to-infectious_ontology","page":"Multiple-strain Disease Model with Vaccination","title":"Morphism from strain_ontology to infectious_ontology","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We use oapply_typed on a UWD representation of the strain_ontology, but note that we could also directly define the map using ACSetTransformation. The result is a morphism P_strainto P_infectious.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"strain_ont_uwd = @relation (Uninf,Inf) where (Uninf::Pop, Inf::Pop) begin\n  infect(Uninf, Inf, Inf, Inf)\n  disease(Inf, Inf)\n  strata(Inf, Inf)\n  strata(Uninf, Uninf)\nend\nstrain_ont_act = oapply_typed(infectious_ontology,strain_ont_uwd,[:infect,:disease,:strataI,:strataU])\n\nto_graphviz(strain_ont_act)","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-simple-trip-model-between-N-regions","page":"Multiple-strain Disease Model with Vaccination","title":"Define simple-trip model between N regions","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"To demonstrate stratification utilizing post-composition to re-type the models, we use the simple-trip geographic model, defined fully in the stratification tutorial. It is typed by infectious_ontology (P_infectious).","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"function travel_model(n)\n  uwd = RelationDiagram(repeat([:Pop], n))\n  junctions = Dict(begin\n    variable = Symbol(\"Region$(i)\")\n    junction = add_junction!(uwd, :Pop, variable=variable)\n    set_junction!(uwd, port, junction, outer=true)\n    variable => junction\n  end for (i, port) in enumerate(ports(uwd, outer=true)))\n\n  pairs = filter(x -> first(x) != last(x), collect(Iterators.product(keys(junctions), keys(junctions))))\n  for pair in pairs\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:strata)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n\n  act = oapply_typed(infectious_ontology, uwd, [Symbol(\"$(a)_$(b)\") for (a, b) in pairs])\n  add_reflexives(act, repeat([[:infect, :disease]], n), infectious_ontology)\nend\n\nfunction living_model(n)\n  typed_living = pairwise_id_typed_petri(infectious_ontology, :Pop, :infect, [Symbol(\"Living$(i)\") for i in 1:n])\n  add_reflexives(typed_living, repeat([[:disease, :strata]], n), infectious_ontology)\nend\n\nsimple_trip_model = typed_product(travel_model(2), living_model(2))\n\nto_graphviz(simple_trip_model)","category":"page"},{"location":"generated/epidemiology/disease_strains/#Stratify-multi-strain-SIR-and-simple-trip-models","page":"Multiple-strain Disease Model with Vaccination","title":"Stratify multi-strain SIR and simple-trip models","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"If we want to use the simple trip model to stratify our multi-strain SIR model, we have a problem because the multi-strain SIR model is typed over P_strain, that is, it is a morphism phi  P to P_strain. Therefore, we can compose with the morphism strain_ont_act (P_strainto P_infectious) we made earlier, to get a new morphism from P to P_infectious.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain_retyped = compose(sir_strain,strain_ont_act)","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We can now take the typed product to get the multi-strain SIR model stratified over the simple trip model of movement between different regions.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain_trip = typed_product(sir_strain_retyped,simple_trip_model)\n\nto_graphviz(dom(sir_strain_trip))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-a-multi-strain-SIR-model-with-vaccination-by-multiple-vaccine-types","page":"Multiple-strain Disease Model with Vaccination","title":"Define a multi-strain SIR model with vaccination by multiple vaccine types","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"Because the multi-vaccine model was typed according to P_infectious, our retyped multi-strain SIR can be stratified according to the multiple vaccine model in a similar way.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain_vax = typed_product(sir_strain_retyped,vax_model(2))\n\nto_graphviz(dom(sir_strain_vax))","category":"page"},{"location":"generated/epidemiology/disease_strains/#Re-stratify-the-multi-strain-multi-vax-SIRD-model-with-the-simple-trip-model","page":"Multiple-strain Disease Model with Vaccination","title":"Re-stratify the multi-strain multi-vax SIRD model with the simple trip model","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"If we would like to stratify our SIR-strain-vaccine model (sir_strain_vax) with the simple trip model, we again face a difficulty. These two models are both typed by P_infectious, but both the \"vaccination\" transitions of the first model and the \"travel\" transitions of the second are currently typed to the :strata transition of the infectious_ontology type system. Naively stratifying would thus produce transitions in which persons traveled and were vaccinated simultaneously.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"To appropriately stratify, we need an additional \"strata\" transition to distinguish between the two types of transitions. We can again use post-compostion with the morphism between type systems to reuse our existing models.","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-an-augmented-version-of-the-infectious_ontology-type-system-with-an-additional-\"strata\"-transition","page":"Multiple-strain Disease Model with Vaccination","title":"Define an augmented version of the infectious_ontology type system with an additional \"strata\" transition","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"const aug_inf_ontology = LabelledPetriNet(\n  [:nPop],\n  :ninfect => ((:nPop, :nPop) => (:nPop, :nPop)),\n  :ndisease => (:nPop => :nPop),\n  :nstrata => (:nPop => :nPop),\n  :nstrata2 => (:nPop => :nPop)\n)\n\nto_graphviz(aug_inf_ontology)","category":"page"},{"location":"generated/epidemiology/disease_strains/#Define-morphisms-from-the-original-type-system-to-the-new-augmented-type-system","page":"Multiple-strain Disease Model with Vaccination","title":"Define morphisms from the original type system to the new augmented type system","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We form one morphism that maps the :strata transition to :nstrata. This morphism will serve to re-type the SIRD-strain-vax model.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"function retype_inf_ont(strata_map)\n  uwd = RelationDiagram([:nPop])\n  variable = :Pop\n  junction = add_junction!(uwd, :nPop, variable=variable)\n  port = ports(uwd, outer=true)[1]\n  set_junction!(uwd, port, junction, outer=true)\n  junctions = Dict(variable => junction)\n\n  boxes = [:ninfect, :ndisease, strata_map]\n  for bname in boxes\n    if bname == :ninfect\n      pair = (:Pop, :Pop, :Pop, :Pop)\n    else\n      pair = (:Pop, :Pop)\n    end\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=bname)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n\n  act = oapply_typed(aug_inf_ontology, uwd, [:infect, :disease, :strata])\nend\n\ninf_ont_act = retype_inf_ont(:nstrata)\n\nto_graphviz(inf_ont_act)","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"We form another morphism that maps the :strata transition to :nstrata2. This morphism will serve to re-type the simple trip model.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"rgn_ont_act = retype_inf_ont(:nstrata2)\n\nto_graphviz(rgn_ont_act)","category":"page"},{"location":"generated/epidemiology/disease_strains/#Add-reflexive-transitions","page":"Multiple-strain Disease Model with Vaccination","title":"Add reflexive transitions","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"To finish preparing for stratification, we need to add the new reflexive transitions to the component models. To the SIR-strain-vax model, we add an :nstrata2 tranisiton to each state. Note that if the model included a decreased (or any other immobile) state, we would not add a reflexive transition to them, as they cannot travel.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain_vax_retyped = flatten_labels(compose(sir_strain_vax,inf_ont_act))\nreflx = [[:nstrata2]]\nfor ii in 2:ns(dom(sir_strain_vax_retyped))\n    push!(reflx,[:nstrata2])\nend\naug_sir_strain_vax = add_reflexives(sir_strain_vax_retyped, reflx, aug_inf_ontology);\nnothing #hide","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"To the simple trip model, we add an :nstrata tranisiton for each state.","category":"page"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"simple_trip_retyped = flatten_labels(compose(simple_trip_model,rgn_ont_act))\naug_trip = add_reflexives(simple_trip_retyped, repeat([[:nstrata]],ns(dom(simple_trip_retyped))), aug_inf_ontology);\nnothing #hide","category":"page"},{"location":"generated/epidemiology/disease_strains/#Stratify-the-SIR-strain-vax-and-simple-trip-models","page":"Multiple-strain Disease Model with Vaccination","title":"Stratify the SIR-strain-vax and simple trip models","text":"","category":"section"},{"location":"generated/epidemiology/disease_strains/","page":"Multiple-strain Disease Model with Vaccination","title":"Multiple-strain Disease Model with Vaccination","text":"sir_strain_vax_trip = typed_product([aug_sir_strain_vax,aug_trip])\n\nto_graphviz(dom(sir_strain_vax_trip))","category":"page"},{"location":"#AlgebraicPetri.jl","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"","category":"section"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"CurrentModule = AlgebraicPetri","category":"page"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"AlgebraicPetri.jl is a Julia package for building Petri Net models compositionally. This package depends on Catlab.jl which provides a framework for applied category theory (ACT) in Julia, and is part of the AlgebraicJulia organization, which develops ACT-based software to improve scientific and technical computing.","category":"page"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"AlgebraicPetri.jl defines the category of open Petri nets as described in [Baez 2018], and implements composition and stratification methods for such Petri nets from [Libkind 2022].","category":"page"},{"location":"#Getting-started","page":"AlgebraicPetri.jl","title":"Getting started","text":"","category":"section"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"Please visit the documentation to learn more about how to use the package. For more details on the underlying theory, please consult [Baez 2018] or [Libkind 2022], with the latter being more oriented towards applied practitioners.","category":"page"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"Tutorials are organized by theme. Currently examples from epidemiology are the most developed. The basic tutorial introduces the main themes of compositional modeling with open Petri nets, followed by a detailed tutorial on model stratification, and a detailed example of developing a complex model with multiple strains of a directly-transmitted disease with vaccines.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"EditURL = \"../../../literate/predation/lotka-volterra.jl\"","category":"page"},{"location":"generated/predation/lotka-volterra/#predation_example","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"(Image: )","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"using AlgebraicPetri\n\nusing OrdinaryDiffEq\nusing Plots\n\nusing Catlab\nusing Catlab.Graphics\nusing Catlab.WiringDiagrams\nusing Catlab.CategoricalAlgebra\nusing Catlab.Programs.RelationalPrograms\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\nnothing #hide","category":"page"},{"location":"generated/predation/lotka-volterra/#Introduction","page":"Lotka-Volterra Model","title":"Introduction","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"In this tutorial we use the Lotka-Volterra model, a classic mathematical model from ecology, to demonstrate basic concepts of compositional model building using AlgebraicPetri.","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-1:-Define-the-building-block-Petri-nets-needed-to-construct-the-model.","page":"Lotka-Volterra Model","title":"Step 1: Define the building block Petri nets needed to construct the model.","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"These are the basic Petri nets which will be substituted as concrete models in the compositional syntax. There are three processes which we need to represent explicitly: birth, predation, and death. Because these models will be composed, we use Open to generate an open Petri net. When given only a single argument, Open generates a structured multicospan, which is an object containing the original Petri net S (accessed by apex), a list of finite sets A_1dotsA_n (accessed by feet), and morphisms A_1to SdotsA_nto S (accessed by legs). The feet are where the Petri net may interact with other systems, justifying the term \"open\" Petri nets.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"The basic Petri nets are generated and the apex of each open Petri net is displayed.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"birth_petri = Open(PetriNet(1, 1=>(1,1)));\nto_graphviz(birth_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"predation_petri = Open(PetriNet(2, (1,2)=>(2,2)));\nto_graphviz(predation_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"death_petri = Open(PetriNet(1, 1=>()));\nto_graphviz(death_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-2:-Specify-interaction-between-submodels-using-a-relational-syntax","page":"Lotka-Volterra Model","title":"Step 2: Specify interaction between submodels using a relational syntax","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"To stitch independent open Petri nets together into a combined model, we need to specify an interaction pattern (composition syntax). This is specified as an undirected wiring diagram (UWD) using the @relation macro from Catlab.jl, please see the documentation there for more information.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"The UWD produced here consists of 3 \"boxes\" and 2 \"junctions\". Boxes connect to junctions via wires based on the function-like syntax in the macro. Wires that lead off the display are \"outer ports\" indicating how output may be collected from the combined system.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"We use oapply to substitute the open Petri nets constructed earlier into each box of the UWD, where the feet of each open Petri net are identified with the wires from each box to shared junctions. The result of oapply is, once again, a multicospan, where the legs now give the map between outer ports of the composed model to places.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lotka_volterra = @relation (wolves, rabbits) begin\n  birth(rabbits)\n  predation(rabbits, wolves)\n  death(wolves)\nend\ndisplay_uwd(lotka_volterra)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lv_dict = Dict(:birth=>birth_petri, :predation=>predation_petri, :death=>death_petri);\nlotka_petri = apex(oapply(lotka_volterra, lv_dict))\nto_graphviz(lotka_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"We can now define an initial state u0, reaction rate constants for each transition p, and use the method vectorfield to create a function we can pass to a differential equation solver to simulate and plot a trajectory of our composed Lotka-Volterra model.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"u0 = [100, 10];\np = [.3, .015, .7];\nprob = ODEProblem(vectorfield(lotka_petri),u0,(0.0,100.0),p);\nsol = solve(prob,Tsit5(),abstol=1e-8);\nplot(sol, labels=[\"Rabbits\" \"Wolves\"])","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-3:-Extend-your-model-to-handle-more-complex-phenomena","page":"Lotka-Volterra Model","title":"Step 3: Extend your model to handle more complex phenomena","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"By making a larger UWD to describe, we can describe a small food chain between little fish, big fish, and sharks.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"dual_lv = @relation (fish, Fish, Shark) begin\n  birth(fish)\n  predation(fish, Fish)\n  death(Fish)\n  predation(Fish, Shark)\n  death(Shark)\nend\ndisplay_uwd(dual_lv)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"dual_lv_petri = apex(oapply(dual_lv, lv_dict))\nto_graphviz(dual_lv_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Generate a new solver, provide parameters, and analyze results","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"u0 = [100, 10, 2];\np = [.3, .015, .7, .017, .35];\nprob = ODEProblem(vectorfield(dual_lv_petri),u0,(0.0,100.0),p);\nsol = solve(prob,Tsit5(),abstol=1e-6);\nplot(sol, label=[\"Little fish\" \"Big fish\" \"Sharks\"])","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"However, at this point it is natural to be concerned about the scalability of needing to define the UWD for larger models; is there a way to compose UWDs themselves to get a larger UWD? As you may have guessed, the answer is yes. Let's see how.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Let's say we want to include another predator of rabbits into the model, hawks. Hawks will behave like flying wolves in this setup, but they don't need to.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lotka_volterra_hawk = @relation (hawks, rabbits) begin\n  birth(rabbits)\n  predation(rabbits, hawks)\n  death(hawks)\nend\ndisplay_uwd(lotka_volterra_hawk)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"We would like to \"glue\" the two UWDs describing terrestrial and aerial predation together along the rabbits junction and birth box. We cannot simply take a disjoint union of the two UWDs (coproduct) as then we would be modelling two disconnected systems. Instead we need to perform a categorical operation called a \"pushout\", which is like a disjoint union but where certain elements are glued together.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"We specify this overlap between the two systems where we will glue them together below.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"rabbit_uwd = @relation (rabbits,) begin\n  birth(rabbits)\nend\ndisplay_uwd(rabbit_uwd)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Next we need to define mappings from this overlap into each of the UWDs we want to glue together. We use the ACSetTransformation method from Catlab for this, which defines a natural transformation between two C-Sets. The result is a \"span\", where the apex is the overlap, and the acset transformations are arrows from the apex into each of the original UWDs. We take the pushout of the span to glue the UWDs together along the apex.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"hawk_transform  = ACSetTransformation((Box=[1], Junction=[2], Port=[1], OuterPort=[2]), rabbit_uwd, lotka_volterra_hawk)\nwolf_transform = ACSetTransformation((Box=[1], Junction=[2], Port=[1], OuterPort=[2]), rabbit_uwd, lotka_volterra)\nlotka_volterra_composed = ob(pushout(hawk_transform, wolf_transform))\n\ndisplay_uwd(lotka_volterra_composed)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Now that we have the composition syntax for the combined terrestrial-aerial predation system, we can substitute concrete mathematical models (open Petri nets) into each box as before to produce a concrete model of the composed system.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lotka_petri = apex(oapply(lotka_volterra_composed, lv_dict))\nto_graphviz(lotka_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"We may now again interpret the model as a differential equation, solve, and plot the solution.","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"u0 = [10.0, 100.0, 50.0];\np = [.3, .015, .7, 0.01, 0.5];\nprob = ODEProblem(vectorfield(lotka_petri),u0,(0.0,100.0),p);\nsol = solve(prob,Tsit5());\nplot(sol, label=[\"Rabbits\" \"Wolves\" \"Hawks\"])","category":"page"}]
}
