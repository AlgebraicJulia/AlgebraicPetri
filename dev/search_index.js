var documenterSearchIndex = {"docs":
[{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/predation/lotka-volterra.jl\"","category":"page"},{"location":"generated/predation/lotka-volterra/#predation_example","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"(Image: )","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"using AlgebraicPetri\n\nusing OrdinaryDiffEq\nusing Plots\n\nusing Catlab\nusing Catlab.Graphics\nusing Catlab.WiringDiagrams\nusing Catlab.CategoricalAlgebra\nusing Catlab.Programs.RelationalPrograms\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\nnothing #hide","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-1:-Define-the-building-block-Petri-nets-needed-to-construct-the-model","page":"Lotka-Volterra Model","title":"Step 1: Define the building block Petri nets needed to construct the model","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"birth_petri = Open(PetriNet(1, 1=>(1,1)));\nto_graphviz(birth_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"predation_petri = Open(PetriNet(2, (1,2)=>(2,2)));\nto_graphviz(predation_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"death_petri = Open(PetriNet(1, 1=>()));\nto_graphviz(death_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-2:-Generate-models-using-a-relational-syntax","page":"Lotka-Volterra Model","title":"Step 2: Generate models using a relational syntax","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lotka_volterra = @relation (wolves, rabbits) begin\n  birth(rabbits)\n  predation(rabbits, wolves)\n  death(wolves)\nend\ndisplay_uwd(lotka_volterra)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"lv_dict = Dict(:birth=>birth_petri, :predation=>predation_petri, :death=>death_petri);\nlotka_petri = apex(oapply(lotka_volterra, lv_dict))\nto_graphviz(lotka_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Generate appropriate vector fields, define parameters, and visualize solution","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"u0 = [100, 10];\np = [.3, .015, .7];\nprob = ODEProblem(vectorfield(lotka_petri),u0,(0.0,100.0),p);\nsol = solve(prob,Tsit5(),abstol=1e-8);\nplot(sol)","category":"page"},{"location":"generated/predation/lotka-volterra/#Step-3:-Extend-your-model-to-handle-more-complex-phenomena","page":"Lotka-Volterra Model","title":"Step 3: Extend your model to handle more complex phenomena","text":"","category":"section"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"such as a small food chain between little fish, big fish, and sharks","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"dual_lv = @relation (fish, Fish, Shark) begin\n  birth(fish)\n  predation(fish, Fish)\n  death(Fish)\n  predation(Fish, Shark)\n  death(Shark)\nend\ndisplay_uwd(dual_lv)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"dual_lv_petri = apex(oapply(dual_lv, lv_dict))\nto_graphviz(dual_lv_petri)","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"Generate a new solver, provide parameters, and analyze results","category":"page"},{"location":"generated/predation/lotka-volterra/","page":"Lotka-Volterra Model","title":"Lotka-Volterra Model","text":"u0 = [100, 10, 2];\np = [.3, .015, .7, .017, .35];\nprob = ODEProblem(vectorfield(dual_lv_petri),u0,(0.0,100.0),p);\nsol = solve(prob,Tsit5(),abstol=1e-6);\nplot(sol)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/bilayerconversion.jl\"","category":"page"},{"location":"generated/covid/bilayerconversion/#bilayernetwork_example","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"","category":"section"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"(Image: )","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"using Pkg Pkg.status() Pkg.activate(\".\")","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Pkg.instantiate()","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Pkg.develop(path=\"../../\") Pkg.instantiate()","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"using AlgebraicPetri\nusing AlgebraicPetri.Epidemiology\nusing AlgebraicPetri.BilayerNetworks\n\nusing Catlab\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphics\nimport Catlab.CategoricalAlgebra: migrate!\nusing Catlab.WiringDiagrams\nusing Catlab.Programs.RelationalPrograms\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\n\nusing PrettyTables\nfunction printsoln(bn::AbstractLabelledBilayerNetwork, soln::Vector)\n    pretty_table(soln)\nend","category":"page"},{"location":"generated/covid/bilayerconversion/#SIR-Model:","page":"Converting Models to Computation Graphs","title":"SIR Model:","text":"","category":"section"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"define model","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"sir = @relation (s,i,r) begin\n    infection(s,i)\n    recovery(i,r)\nend\ndisplay_uwd(sir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Extract the Petri network form of the model.","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"psir = apex(oapply_epi(sir))\npsir\nto_graphviz(psir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"Convert the Petri network into a bilayer network and draw it. This model uses a computation graph to express the computation of the vector field of the Petri net.","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnsir = BilayerNetwork()\nmigrate!(bnsir, psir)\nbnsir\nto_graphviz(bnsir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"We can hand code a Bilayer netowork using the @acset macro provided by Catlab. As you can see from the code, there is a lot of typing to specify the incidence of all these wires. The Petri Net is more compact. This notion of Bilayer network comes from the definition of mass action kinetics for reaction networks.","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"hand coded Bilayer network","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnsir_test = @acset BilayerNetwork begin\n    Qin = 3\n    Qout = 3\n    Win = 3\n    Wa = 3\n    Wn = 3\n    Box = 2\n    arg = [1,2,2]\n    call = [1,1,2]\n    efflux = [1,1,2]\n    effusion = [1,2,2]\n    influx = [1,1,2]\n    infusion = [2,2,3]\nend\n\n@assert bnsir == bnsir_test\n\nfunction roundtrip(pn::AbstractPetriNet, bn::AbstractBilayerNetwork)\n    roundtrippetri = PetriNet()\n    migrate!(roundtrippetri, bn)\n    pn_structure = PetriNet()\n    copy_parts!(pn_structure, pn)\n    return roundtrippetri, pn_structure\nend","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"We can specify the SEIR model with the relation macro and functorial semantics as usual.","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"seir = @relation (s,e,i,r) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\nend\n\npseir = apex(oapply_epi(seir))","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"By converting this to a Bilayer network, we are able to visualize differences in the computational pattern of data flow between different reaction network models.","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnseir = BilayerNetwork()\nmigrate!(bnseir, pseir)\n\nbnrt,pnstr = roundtrip(pseir, bnseir)\n\ndisplay_uwd(sir)\n\nto_graphviz(psir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnsir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnseir)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"to_graphviz(bnrt)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"qm = @relation (s,q) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    quarexp(e,q)\n    quarinf(i,q)\nend\ndisplay_uwd(qm)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.Epidemiology: exposure_petri, spontaneous_petri\nsemantics = Dict(\n    :infection => exposure_petri(:S, :I, :I, :inf),\n    :exposure  => exposure_petri(:S, :I, :E, :exp),\n    :illness   => spontaneous_petri(:E,:I,:ill),\n    :recovery  => spontaneous_petri(:I,:R,:rec),\n    :death     => spontaneous_petri(:I,:D,:death),\n    :quarexp   => spontaneous_petri(:E, :Q, :qe),\n    :quarinf   => spontaneous_petri(:I, :Q, :qi),\n    :quarrec   => spontaneous_petri(:Q, :R, :qr)\n)\npn_quar = oapply(qm, semantics)  |> apex\nto_graphviz(pn_quar)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnquar = LabelledBilayerNetwork()\nmigrate!(bnquar, pn_quar)\nto_graphviz(bnquar)\n\nqm = @relation (s,i,q) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    quarexp(e,q)\n    quarinf(i,q)\n    quarrec(q,r)\nend\ndisplay_uwd(qm)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"pn_quar = oapply(qm, semantics)  |> apex\nto_graphviz(pn_quar)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"bnquar = LabelledBilayerNetwork()\nmigrate!(bnquar, pn_quar)\nto_graphviz(bnquar)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"quarrt = LabelledPetriNet()\nmigrate!(quarrt, bnquar) |> to_graphviz\n\nbnquar","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.BilayerNetworks: evaluate!, evaluate\n\nbnsir = LabelledBilayerNetwork()\nmigrate!(bnsir, psir)\n\nevaluate(bnsir, [10.0, 1, 0.0], inf=0.1, rec=0.3)\n\nevaluate(bnquar, [10.0, 1, 0, 0,0,0], exp=0.1, rec=0.3, qi=0.2, ill=0.7, qe=0.23, qr=0.3)\n\nfunction euler(bn::AbstractLabelledBilayerNetwork, state, nsteps::Integer, stepsize::Real; params...)\n    #preallocate storage so that each step is nonallocating\n    #create a storage space for steps of euler's method store intermediate\n    #states as named tuples so that you can integrate with julia Tables.jl data  analysis ecosystem\n    du = zeros(length(state))\n    ϕ = ones(nparts(bn, :Box))\n    u = tuple(state...)\n    results = Vector{NamedTuple{tuple(bn[:,:variable]...)}}()\n    for i in 1:nsteps\n        u = u .+ stepsize.*evaluate!(du, ϕ, bn, u; params...)\n        push!(results, NamedTuple{tuple(bn[:,:variable]...)}(u))\n    end\n    return results\nend\n\nsoln = euler(bnquar, (S=10.0, I=1, E=0, R=0, Q=0), 30, 0.15, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)\nprintsoln(bnquar, soln)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"import AlgebraicPetri.BilayerNetworks: compile\ncompile(bnquar, :du, :ϕ, :u, :p)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"compile(bnquar, :du, :ϕ, :u, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"function eulers(bn::AbstractLabelledBilayerNetwork, funcname::Symbol; params...)\n    f = compile(bn, :du, :ϕ, :u; params...)\n    varnames = tuple(bn[:,:variable]...)\n    nϕ = nparts(bn, :Box)\n    quote\n    function $funcname(state, nsteps::Integer, stepsize::Real)\n        $f\n        #preallocate storage so that each step is nonallocating\n        du = zeros(length(state))\n        ϕ = ones($nϕ)\n        u = tuple(state...)\n        #create a storage space for steps of euler's method\n        #store intermediate states as named tuples so that you can integrate\n        #with julia Tables.jl data analysis ecosystem\n        results = Vector{NamedTuple{$varnames}}()\n        for i in 1:nsteps\n            Δ = f!(du, ϕ, u, 0)\n            u = u .+ stepsize.*Δ\n            push!(results, NamedTuple{$varnames}(u))\n        end\n        return results\n    end\n    end\nend\n\neulers(bnsir, :eulsir, inf=0.3, rec=0.2)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eulseirqexp = eulers(bnquar, :eulseirq, exp=0.1, rec=0.03, qi=0.37, ill=0.7, qe=0.23, qr=0.03)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eulsirexp = eulers(bnsir, :eulsir, inf=0.3, rec=0.2)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eval(eulsirexp)\nsoln_codegen = eulsir((S=10.0, I=1, R=0), 30, 0.15)\npretty_table(soln_codegen)","category":"page"},{"location":"generated/covid/bilayerconversion/","page":"Converting Models to Computation Graphs","title":"Converting Models to Computation Graphs","text":"eval(eulseirqexp)\nsoln_codegen = eulseirq((S=10.0, I=1, E=0, R=0, Q=0), 30, 0.15)\npretty_table(soln_codegen)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"Modules = [AlgebraicPetri, AlgebraicPetri.Epidemiology, AlgebraicPetri.OpenTransitions]","category":"page"},{"location":"api/#AlgebraicPetri.AlgebraicPetri","page":"Library Reference","title":"AlgebraicPetri.AlgebraicPetri","text":"Computing in the category of finite sets and Petri cospans\n\n\n\n\n\n","category":"module"},{"location":"api/#AlgebraicPetri.SchLabelledPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchLabelledPetriNet","text":"ACSet definition for a Petri net with labels on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchLabelledReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchLabelledReactionNet","text":"ACSet definition for a ReactionNet with labels on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPetriNet","text":"ACSet definition for a Petri net.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyLabelledPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyLabelledPetriNet","text":"ACSet definition for a LabelledPetriNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyLabelledReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyLabelledReactionNet","text":"ACSet definition for a LabelledReactionNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyPetriNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyPetriNet","text":"ACSet definition for a PetriNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchPropertyReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchPropertyReactionNet","text":"ACSet definition for a ReactionNet with properties on transitions and states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.SchReactionNet","page":"Library Reference","title":"AlgebraicPetri.SchReactionNet","text":"ACSet definition for a Petri net with rates on transitions and concentrations on states.\n\nSee Catlab.jl documentation for description of the @present syntax.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.AbstractPetriNet","page":"Library Reference","title":"AlgebraicPetri.AbstractPetriNet","text":"Abstract type for C-sets that contain a petri net.\n\nThis type encompasses C-sets where the schema for graphs is a subcategory of C. This includes, for example, graphs, symmetric graphs, and reflexive graphs, but not half-edge graphs.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicPetri.AbstractPropertyPetriNet","page":"Library Reference","title":"AlgebraicPetri.AbstractPropertyPetriNet","text":"Abstract Type for any PetriNet ACSet with  properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicPetri.LabelledPetriNet-Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}","page":"Library Reference","title":"AlgebraicPetri.LabelledPetriNet","text":"LabelledPetriNet(n, ts::Vararg{Union{Pair,Tuple}})\n\nConstructs a LabelledPetriNet object with state names as elements of n and labelled transitions described by ts. Transitions are given as transition_name=>((input_states)=>(output_states)).\n\nA LabelledPetriNet modelling the SIR model with 3 states and 2 transitions can be constructed as follows:\n\nLabelledPetriNet([:S, :I, :R], :inf=>((:S,:I)=>(:I,:I)), :rec=>(:I=>:R))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.LabelledReactionNet-Union{Tuple{C}, Tuple{R}, Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}} where {R, C}","page":"Library Reference","title":"AlgebraicPetri.LabelledReactionNet","text":"LabelledReactionNet{R,C}(n, ts::Vararg{Union{Pair,Tuple}}) where {R,C}\n\nConstructs a LabelledReactionNet object with labelled state concentrations as elements of n and labelled transitions described by ts. R is the data type used to store rates and C is the data type used to store concentrations.\n\nTransitions are given as (t_name=>t_rate)=>((input_states)=>(output_states)).\n\nA LabelledReactionNet modelling the SIR model with 3 states and 2 transitions, an initial population of 10 susceptible, 1 infected, 0 recovered and an infection rate of 0.5 and recovery rate of 0.1 can be constructed as follows:\n\nReactionNet{Float64, Float64}([:S=>10,:I=>1,:R=>0], (:inf=>0.5)=>((1,2)=>(2,2)), (:rec=>0.1)=>(2=>3))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ReactionNet-Union{Tuple{C}, Tuple{R}, Tuple{Union{Tuple, AbstractVector}, Vararg{Union{Tuple, Pair}}}} where {R, C}","page":"Library Reference","title":"AlgebraicPetri.ReactionNet","text":"ReactionNet{R,C}(n, ts::Vararg{Union{Pair,Tuple}}) where {R,C}\n\nConstructs a ReactionNet object with state concentrations as elements of n and transitions described by ts. R is the data type used to store rates and C is the data type used to store concentrations.\n\nTransitions are given as transition_rate=>((input_states)=>(output_states)).\n\nA ReactionNet modelling the SIR model with 3 states and 2 transitions, an initial population of 10 susceptible, 1 infected, 0 recovered and an infection rate of 0.5 and recovery rate of 0.1 can be constructed as follows:\n\nReactionNet{Float64, Float64}([10,1,0], 0.5=>((1,2)=>(2,2)), 0.1=>(2=>3))\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.TransitionMatrices","page":"Library Reference","title":"AlgebraicPetri.TransitionMatrices","text":"TransitionMatrices\n\nThis data structure stores the transition matrix of an AbstractPetriNet object. This is primarily used for constructing the vectorfield representation of the Petri net.\n\n\n\n\n\n","category":"type"},{"location":"api/#Core.Type-Union{Tuple{AbstractPetriNet}, Tuple{T}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(pn::AbstractPetriNet)\n\nCast one type of AbstractPetriNet to another. Any unrepresented parts will be nothing.\n\npn = PetriNet(3, (1,2)=>(2,2), 2=>3)\nlabelled_pn = LabelledPetriNet(pn)\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{TransitionMatrices}, Tuple{T}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(tm::TransitionMatrices)\n\nConstruct any AbstractPetriNet from a given transition matrice representation.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{T}, Tuple{AbstractPetriNet, Any, Any}} where T<:AbstractPropertyPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPropertyPetriNet)(pn::AbstractPetriNet, sprops, tprops)\n\nAdd properties to the states and transitions of a given Petri Net.\n\n\n\n\n\n","category":"method"},{"location":"api/#Core.Type-Union{Tuple{T}, Tuple{Int64, Vararg{Union{Tuple, Pair}}}} where T<:AbstractPetriNet","page":"Library Reference","title":"Core.Type","text":"(::AbstractPetriNet)(n::Int, ts::Vararg{Union{Pair,Tuple}})\n\nConstructs any AbstractPetriNet object with n states and transitions described by ts. Transitions are given as (input_states)=>(output_states).\n\nA PetriNet modelling the SIR model with 3 states and 2 transitions can be constructed as follows:\n\nPetriNet(3, (1,2)=>(2,2), 2=>3)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{AbstractPetriNet, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(p::AbstractPetriNet, legs...)\n\nGenerates on OpenPetriNet with legs bundled as described by legs\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(p::AbstractPetriNet)\n\nConverts a PetriNet to an OpenPetriNet where each state is exposed as a leg of the cospan. The OpenPetriNet can be composed over an undirected wiring diagram (see this blog post for a description of this compositional tooling)\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Open-Tuple{Any, AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.Open","text":"Open(n, p::AbstractPetriNet, m)\n\nGenerates on OpenPetriNet with two legs, n and m\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_input!-Tuple{AbstractPetriNet, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_input!","text":"add_input!(p::AbstractPetriNet,t,s;kw...)\n\nAdd an input relationship to the Petri net between the transition t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_inputs!-Tuple{AbstractPetriNet, Any, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_inputs!","text":"add_inputs!(p::AbstractPetriNet,n,t,s;kw...)\n\nAdd input relationships to the Petri net between the transitions t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_output!-Tuple{AbstractPetriNet, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_output!","text":"add_output!(p::AbstractPetriNet,t,s;kw...)\n\nAdd an output relationship to the Petri net between the transition t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_outputs!-Tuple{AbstractPetriNet, Any, Any, Any}","page":"Library Reference","title":"AlgebraicPetri.add_outputs!","text":"add_outputs!(p::AbstractPetriNet,n,t,s;kw...)\n\nAdd output relationships to the Petri net between the transitions t and species s.\n\nReturns the ID of the input relationship\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_species!-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.add_species!","text":"Add n species to the Petri net. Label and concentration can be provided depending on the kind of Petri net.\n\nReturns the ID of the species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_species!-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.add_species!","text":"Add a species to the Petri net. Label and concentration can be provided depending on the kind of Petri net.\n\nReturns the ID of the species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_transition!-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.add_transition!","text":"Add a transition to the Petri net. Label and rate can be provided depending on the kind of Petri net.\n\nReturns the ID of the transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.add_transitions!-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.add_transitions!","text":"Add n transitions to the Petri net. Label and rate can be provided depending on the kind of Petri net.\n\nReturns the ID of the transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.concentration-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.concentration","text":"Concentration of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.concentrations-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.concentrations","text":"All concentrations of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.flatten_labels-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.flatten_labels","text":"flatten_labels(pn::AbstractPetriNet)\n\nTakes a labelled Petri net or reaction net and flattens arbitrarily nested labels on the species and the transitions to a single symbol who's previously nested parts are separated by _.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.inputs-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.inputs","text":"Input relationships for a transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ni-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.ni","text":"Number of input relationships in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.no-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.no","text":"Number of output relationships in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.ns-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.ns","text":"Number of states in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.nt-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.nt","text":"Number of transitions in a Petri net\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.outputs-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.outputs","text":"Output relationships for a transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.rate-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.rate","text":"Rate of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.rates-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.rates","text":"All rates of a ReactionNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sname-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.sname","text":"Name of species\n\nNote that this returns an index if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.snames-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.snames","text":"Names of species in  a Petri net\n\nNote that this returns indices if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sprop-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.sprop","text":"Property of species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.sprops-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.sprops","text":"Properties of all species\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tname-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.tname","text":"Name of transition\n\nNote that this returns an index if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tnames-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.tnames","text":"Names of transitions in  a Petri net\n\nNote that this returns indices if labels are not present in the PetriNet\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tprop-Tuple{AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.tprop","text":"Property of transition\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.tprops-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.tprops","text":"Properties of all transitions\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.vectorfield-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.vectorfield","text":"vectorfield(pn::AbstractPetriNet)\n\nGenerates a Julia function which calculates the vectorfield of the Petri net being simulated under the law of mass action.\n\nThe resulting function has a signature of the form f!(du, u, p, t) and can be passed to the DifferentialEquations.jl solver package.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.vectorfield_expr-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.vectorfield_expr","text":"vectorfield_expr(pn::AbstractPetriNet)\n\nGenerates a Julia expression which is then evaluated that  calculates the  vectorfield of the Petri net being simulated under the law of mass action.\n\nThe resulting function has a signature of the form f!(du, u, p, t) and can be passed to the DifferentialEquations.jl solver package.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.Epidemiology","page":"Library Reference","title":"AlgebraicPetri.Epidemiology","text":"Specific generators and useful tools for constructing epidemiological systems\n\n\n\n\n\n","category":"module"},{"location":"api/#AlgebraicPetri.Epidemiology.death","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.death","text":"LabelledPetriNet which describes the death process which moves tokens from I to D\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.exposure","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.exposure","text":"LabelledPetriNet which describes the exposure process where tokens in I \"expose\" tokens in S, changing them from S to E\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.illness","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.illness","text":"LabelledPetriNet which describes the illness process which moves tokens from E to I.\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.infection","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.infection","text":"LabelledPetriNet which describes the infection process of tokens in state S by tokens in state I\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.recovery","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.recovery","text":"LabelledPetriNet which describes the recovery process which moves tokens from I to R\n\n\n\n\n\n","category":"constant"},{"location":"api/#AlgebraicPetri.Epidemiology.oapply_epi-Tuple{Any, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.Epidemiology.oapply_epi","text":"oapply_epi(ex, args...)\n\nGenerates a LabelledPetriNet under a composition pattern described by the undirected wiring diagram ex. This requires that the nodes in ex are only labelled with labels from the following set:\n\n[:infection, :exposure, :illness, :recovery, :death]\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{AbstractPetriNet, Vararg{Any}}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(p::AbstractPetriNet, legs...)\n\nGenerates on OpenPetriNetT with legs bundled as described by legs\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{AbstractPetriNet}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(p::AbstractPetriNet)\n\nConverts a PetriNet to an OpenPetriNetT where each transition is exposed as a leg of the cospan. The OpenPetriNetT can be composed over an undirected wiring diagram.\n\n\n\n\n\n","category":"method"},{"location":"api/#AlgebraicPetri.OpenTransitions.OpenT-Tuple{Any, AbstractPetriNet, Any}","page":"Library Reference","title":"AlgebraicPetri.OpenTransitions.OpenT","text":"OpenT(n, p::AbstractPetriNet, m)\n\nGenerates on OpenPetriNetT with two legs, n and m\n\n\n\n\n\n","category":"method"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/enzymes/enzyme_reactions.jl\"","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#enzyme_example","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"(Image: )","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"using AlgebraicPetri\nusing Catlab.Programs\nusing Catlab.Graphics\nusing Catlab.WiringDiagrams\nusing Catlab.CategoricalAlgebra\n\nusing DifferentialEquations\nusing Plots\n\ndisplay_uwd(ex, prog=\"neato\") = to_graphviz(ex, box_labels=:name, junction_labels=:variable, graph_attrs=Dict(:overlap => \"false\"), prog=prog)\node(x, t) = ODEProblem(vectorfield(x), concentrations(x), t, rates(x));\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Define-objects-and-initial-conditions","page":"Cathepsin Enzyme Reactions","title":"Define objects and initial conditions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"ob(x) = codom(Open([first(x)], LabelledReactionNet{Number,Int}([x]), [first(x)])).ob;\nK = :K=>33000;\nS = :S=>33000;\nL = :L=>33000;\nKinact = :Kinact=>0;\nSinact = :Sinact=>0;\nLinact = :Linact=>0;\nE = :E=>700000;\nG = :G=>1300000;\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Helper-functions-for-generating-primitive-Petri-net-operations","page":"Cathepsin Enzyme Reactions","title":"Helper functions for generating primitive Petri net operations","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"inact(in,on::Number) = begin\n  inact = Symbol(first(in), :inact)\n  Open(LabelledReactionNet{Number,Int}(unique((in, inact=>0)), ((Symbol(:inact_,first(in)),on),first(in)=>inact)))\nend;\n\nbind(in1, in2, on::Number, off::Number) = begin\n  out = Symbol(first(in1),first(in2))\n  Open(LabelledReactionNet{Number,Int}(unique((in1, in2,out=>0)), ((Symbol(:bind_,first(in1),first(in2)),on),(first(in1),first(in2))=>out),\n                                                           ((Symbol(:unbind_,out),off),out=>(first(in1),first(in2)))))\nend;\n\ndeg(prod1,prod2,on::Number) = begin\n  in = Symbol(first(prod1),first(prod2))\n  prod2str = String(first(prod2))\n  degprod2 = Symbol(endswith(prod2str, \"inact\") ? first(prod2str) : prod2str, :deg)\n  Open(LabelledReactionNet{Number,Int}(unique((in=>0, prod1,degprod2=>0)), ((Symbol(:deg_,in),on),in=>(first(prod1),degprod2))));\nend;\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-itself","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with itself","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catX = @relation (X, Xinact, Xdeg) where (X, Xinact, Xdeg, XX, XXinact) begin\n  inactX(X, Xinact)\n  bindXX(X, XX)\n  degXX(XX, X, Xdeg)\n  bindXXinact(X, Xinact, XXinact)\n  degXXinact(XXinact, X, Xdeg)\nend\ndisplay_uwd(catX)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-Substrate-*Y*","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with Substrate Y","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catXsubY = @relation (X, Xinact, Xdeg, Y, Ydeg) where (X, Xinact, Xdeg, Y, XY, Ydeg) begin\n  bindXY(X, Y, XY)\n  degXY(XY, X, Ydeg)\nend\ndisplay_uwd(catXsubY)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Cathepsin-*X*-reacting-with-Cathepsin-*Y*","page":"Cathepsin Enzyme Reactions","title":"Cathepsin X reacting with Cathepsin Y","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"catXY = @relation (X, Xinact, Xdeg, Y, Yinact, Ydeg) where (X, Xinact, Xdeg, Y, Yinact, Ydeg, XY, XYinact) begin\n  bindXY(X, Y, XY)\n  degXY(XY, X, Ydeg)\n  bindXYinact(X, Yinact, XYinact)\n  degXYinact(XYinact, X, Ydeg)\nend\ndisplay_uwd(catXY)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Define-all-enzyme-reactions","page":"Cathepsin Enzyme Reactions","title":"Define all enzyme reactions","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"rxns = Dict(\n  :K => [inact(K, 7.494e-10)\n         bind(K, K, 7.814e-4, 3.867e-3)\n         deg(K, K, 2.265e-1)\n         bind(K, Kinact, 7.814e-4, 3.867e-3)\n         deg(K, Kinact, 2.265e-1)],\n  :S => [inact(S, 7.494e-10)\n         bind(S, S, 7.814e-4, 3.867e-3)\n         deg(S, S, 2.265e-1)\n         bind(S, Sinact, 7.814e-4, 3.867e-3)\n         deg(S, Sinact, 2.265e-1)],\n  :L => [inact(L, 7.494e-10)\n         bind(L, L, 7.814e-4, 3.867e-3)\n         deg(L, L, 2.265e-1)\n         bind(L, Linact, 7.814e-4, 3.867e-3)\n         deg(L, Linact, 2.265e-1)],\n  :KE => [bind(K, E, 9.668e-6, 1e-2)\n          deg(K, E, 1.728e0)],\n  :KG => [bind(K, G, 2.764e-6, 8.78e-1)\n          deg(K, G, 1.502)],\n  :SE => [bind(S, E, 4.197e-7, 1.06e-3)\n          deg(S, E, 1.384e4)],\n  :SG => [bind(S, G, 5.152e-8, 3.894e-3)\n          deg(S, G, 8.755e-1)],\n  :LE => [bind(L, E, 1.977e-8, 1e-2)\n          deg(L, E, 1.066e2)],\n  :LG => [bind(L, G, 3.394e-8, 2.365e1)\n          deg(L, G, 4.352)],\n  :KS => [bind(K, S, 8.822e-4, 4.114e5)\n          deg(K, S, 9e-10)\n          bind(K, Sinact, 8.822e-4, 4.114e5)\n          deg(K, Sinact, 9e-10)],\n  :KL => [bind(K, L, 1.756e-4, 3.729e4)\n          deg(K, L, 6.505e6)\n          bind(K, Linact, 1.756e-4, 3.729e4)\n          deg(K, Linact, 6.505e6)],\n  :SK => [bind(S, K, 8.822e-4, 4.114e5)\n          deg(S, K, 9e-10)\n          bind(S, Kinact, 8.822e-4, 4.114e5)\n          deg(S, Kinact, 9e-10)],\n  :SL => [bind(S, L, 1e-3, 5e2)\n          deg(S, L, 1e-7)\n          bind(S, Linact, 1e-3, 5e2)\n          deg(S, Linact, 1e-7)],\n  :LK => [bind(L, K, 1e-3, 4.118e3)\n          deg(L, K, 3.234e1)\n          bind(L, Kinact, 1e-3, 4.118e3)\n          deg(L, Kinact, 3.234e1)],\n  :LS => [bind(L, S, 1.056e-12, 5e2)\n          deg(L, S, 5e-1)\n          bind(L, Sinact, 1.056e-12, 5e2)\n          deg(L, Sinact, 5e-1)]\n);\nnothing #hide","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Helper-functions-to-generate-oapply-calls","page":"Cathepsin Enzyme Reactions","title":"Helper functions to generate oapply calls","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"cat(cat) = begin\n  catsym = first(cat)\n  out = oapply(catX, Dict([:inactX, :bindXX, :degXX, :bindXXinact, :degXXinact] .=> rxns[catsym]), Dict(\n    :X=>ob(cat),\n    :Xinact=>ob(Symbol(catsym,:inact)=>0),\n    :Xdeg=>ob(Symbol(catsym,:deg)=>0),\n    :XX=>ob(Symbol(catsym,catsym)=>0),\n    :XXinact=>ob(Symbol(catsym,catsym,:inact)=>0)))\n  bundle_legs(out, [[1,2,3]])\nend\n\ncat_sub(cat1, sub) = begin\n  catsym = first(cat1)\n  subsym = first(sub)\n  catsub = Symbol(catsym, subsym)\n  out = oapply(catXsubY, Dict([:bindXY, :degXY] .=> rxns[catsub]), Dict(\n    :X=>ob(cat1),\n    :Xinact=>ob(Symbol(catsym,:inact)=>0),\n    :Xdeg=>ob(Symbol(catsym,:deg)=>0),\n    :Y=>ob(sub),\n    :XY=>ob(Symbol(catsym,subsym)=>0),\n    :Ydeg=>ob(Symbol(subsym,:deg)=>0)))\n  bundle_legs(out, [[1,2,3], [4,5]])\nend\n\n\ncat_cat(cat1, cat2) = begin\n  cat1sym = first(cat1)\n  cat2sym = first(cat2)\n  catcat = Symbol(cat1sym, cat2sym)\n  out = oapply(catXY, Dict([:bindXY, :degXY, :bindXYinact, :degXYinact] .=> rxns[catcat]), Dict(\n    :X=>ob(cat1),\n    :Xinact=>ob(Symbol(cat1sym,:inact)=>0),\n    :Xdeg=>ob(Symbol(cat1sym,:deg)=>0),\n    :Y=>ob(cat2),\n    :Yinact=>ob(Symbol(cat2sym,:inact)=>0),\n    :Ydeg=>ob(Symbol(cat2sym,:deg)=>0),\n    :XY=>ob(catcat=>0),\n    :XYinact=>ob(Symbol(catcat,:inact)=>0)))\n  bundle_legs(out, [[1,2,3], [4,5,6]])\nend\n\nfunctor(x) = oapply(x, Dict(\n  :catK=>cat(K),\n  :catS=>cat(S),\n  :catL=>cat(L),\n  :catKcatS=>cat_cat(K,S),\n  :catKcatL=>cat_cat(K,L),\n  :catScatK=>cat_cat(S,K),\n  :catScatL=>cat_cat(S,L),\n  :catLcatK=>cat_cat(L,K),\n  :catLcatS=>cat_cat(L,S),\n  :catKsubE=>cat_sub(K,E),\n  :catSsubE=>cat_sub(S,E),\n  :catLsubE=>cat_sub(L,E),\n  :catKsubG=>cat_sub(K,G),\n  :catSsubG=>cat_sub(S,G),\n  :catLsubG=>cat_sub(L,G)));\n\nfunction enzyme_uwd(enzymes::Array{Symbol}, substrates::Array{Symbol})\n  rel = RelationDiagram(0)\n\n  chemicals = vcat(substrates, enzymes)\n\n  subs = add_junctions!(rel, length(substrates), variable=substrates)\n  enzs = add_junctions!(rel, length(enzymes), variable=enzymes)\n  nsubs = length(subs)\n  nenzs = length(enzs)\n\n  catx = add_parts!(rel, :Box, nenzs, name=[Symbol(\"cat$i\") for i in enzymes])\n  add_parts!(rel, :Port, nenzs, junction=enzs, box=catx)\n\n  for x in 1:nenzs\n    for y in 1:nenzs\n      if y != x\n        catxy = add_part!(rel, :Box, name=Symbol(\"cat$(enzymes[x])cat$(enzymes[y])\"))\n        add_parts!(rel, :Port, 2, junction=[enzs[x], enzs[y]], box=catxy)\n      end\n    end\n  end\n\n  for x in 1:nenzs\n    for y in 1:nsubs\n      catxy = add_part!(rel, :Box, name=Symbol(\"cat$(enzymes[x])sub$(substrates[y])\"))\n      add_parts!(rel, :Port, 2, junction=[enzs[x], subs[y]], box=catxy)\n    end\n  end\n  add_parts!(rel, :OuterPort, length(chemicals), outer_junction = vcat(subs, enzs))\n  rel\nend\n\nenzyme_reaction(args...) = enzyme_uwd(args...) |> functor |> apex","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Manually-Defining-Models","page":"Cathepsin Enzyme Reactions","title":"Manually Defining Models","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE = @relation (K, S, E) begin\n  catK(K)\n  catS(S)\n  catKcatS(K, S)\n  catScatK(S, K)\n  catKsubE(K, E)\n  catSsubE(S, E)\nend\ndisplay_uwd(KSE)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#Defining-Models-using-API","page":"Cathepsin Enzyme Reactions","title":"Defining Models using API","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-Elastin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, Elastin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE = enzyme_uwd([:K, :S], [:E])\ndisplay_uwd(KSE)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSE_petri = apex(functor(KSE))\node_prob = ode(KSE_petri, (0.0, 120.0))\nsol = solve(ode_prob)\n\nplot(sol)","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, lw = 2, ylims = (0, 15000), xlims = (0, 30))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-CatL,-Elastin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, CatL, Elastin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSLE = enzyme_reaction([:K, :S, :L], [:E])\node_prob = ode(KSLE, (0.0,120.0))\nsol = solve(ode_prob)\nplot(sol, lw = 1, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, ylims = (0, 20000), xlims = (0, 30), lw = 2, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/#CatK,-CatS,-CatL,-Elastin,-Gelatin","page":"Cathepsin Enzyme Reactions","title":"CatK, CatS, CatL, Elastin, Gelatin","text":"","category":"section"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"KSLEG = enzyme_reaction([:K, :S, :L], [:E, :G])\node_prob = ode(KSLEG, (0.0,120.0))\nsol = solve(ode_prob)\nplot(sol, lw = 1, size = (1066, 600))","category":"page"},{"location":"generated/enzymes/enzyme_reactions/","page":"Cathepsin Enzyme Reactions","title":"Cathepsin Enzyme Reactions","text":"plot(sol, ylims = (0, 30000), xlims = (0, 50), lw = 2, size = (1066, 600))","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/coexist/coexist.jl\"","category":"page"},{"location":"generated/covid/coexist/coexist/#coexist_example","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"","category":"section"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"(Image: )","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"using AlgebraicPetri\n\nusing LabelledArrays\nusing OrdinaryDiffEq\nusing Plots\nusing JSON\n\nusing Catlab\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphics\nusing Catlab.Programs\nusing Catlab.Theories\nusing Catlab.WiringDiagrams\nusing Catlab.Graphics.Graphviz: run_graphviz\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\"1\"));\nsave_fig(g, fname::AbstractString, format::AbstractString) = begin\n    open(string(fname, \".\", format), \"w\") do io\n        run_graphviz(io, g, format=format)\n    end\nend","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Define helper functions for defining the two types of reactions in an epidemiology Model. Either a state spontaneously changes, or one state causes another to change","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"ob(x::Symbol,n::Int) = codom(Open([x], LabelledReactionNet{Number,Int}([x=>n]), [x])).ob;\nfunction spontaneous_petri(transition::Symbol, rate::Number,\n                           s::Symbol, s₀::Int,\n                           t::Symbol, t₀::Int)\n    Open(LabelledReactionNet{Number,Int}(unique((s=>s₀,t=>t₀)), (transition,rate)=>(s=>t)))\nend;\nfunction exposure_petri(transition::Symbol, rate::Number,\n                        s::Symbol, s₀::Int,\n                        e::Symbol, e₀::Int,\n                        t::Symbol, t₀::Int)\n    Open(LabelledReactionNet{Number,Int}(unique((s=>s₀,e=>e₀,t=>t₀)), (transition,rate)=>((s,e)=>(t,e))))\nend;\nnothing #hide","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Set arrays of initial conditions and rates to use in functor","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"pop = [8044056, 7642473, 8558707, 9295024,8604251,9173465,7286777,5830635,3450616] .- (4*1000);\nN = sum(pop) + length(pop)*4*1000;\nsocial_mixing_rate =\n  [[5.10316562022642,1.28725377551533,1.30332531065247,2.31497083312315,1.1221598200343,0.606327539457772,0.453266757158743,0.177712174722219,0.0111726265254263],\n   [1.15949254996891,8.00118824220649,1.24977685411394,1.51298690806342,1.88877951844257,0.835804485358679,0.431371281973645,0.343104864504218,0.0324429672946592],\n   [1.19314902456243,1.2701954426234,3.55182053724384,1.81286158254244,1.80561825747571,1.29108026766182,0.708613434860661,0.248559044477893,0.0215323291988856],\n   [1.83125260045684,1.32872195974583,1.56648238384012,2.75491288061819,1.94613663227464,1.2348814962672,0.863177586322153,0.244623623638873,0.0394364256673532],\n   [0.910395333788561,1.7011898591446,1.60014517035071,1.99593275526656,2.90894801031624,1.37683234043657,0.859519958701156,0.488960115017174,0.110509077357166],\n   [0.56560186656657,0.865574490657954,1.31557291022074,1.45621698394508,1.58310342861768,1.92835669973181,0.963568493650797,0.463041280007004,0.183483677017087],\n   [0.544954016221808,0.575775829452094,0.930622416907882,1.31190809759635,1.27375718214796,1.24189546255302,1.32825334016313,0.66235513907445,0.0946971569608397],\n   [0.319717318035767,0.68528632728864,0.488468642570909,0.556345582530282,1.08429412751444,0.893028152305907,0.991137484161889,1.17651345255182,0.12964732712923],\n   [0.201086389216809,0.648252461859761,0.423327560644352,0.897268061280577,2.4516024037254,3.54014694719397,1.41761515077768,1.29700599099082,1.0189817510854]];\n\nfatality_rate = [0.00856164, 0.03768844, 0.02321319, 0.04282494, 0.07512237, 0.12550367, 0.167096  , 0.37953452, 0.45757006];\nnothing #hide","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Define an oapply function that connects the building block Petri nets to the operations we will use in the model.","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"F(ex, n) = oapply(ex, Dict(\n    :exposure=>exposure_petri(Symbol(:exp_, n), 1*social_mixing_rate[n][n]/pop[n], Symbol(:S,n), pop[n], Symbol(:I,n), 1000, Symbol(:E,n), 1000),\n    :exposure_e=>exposure_petri(Symbol(:exp_e, n), .01*social_mixing_rate[n][n]/pop[n], Symbol(:S,n), pop[n], Symbol(:E,n),1000, Symbol(:E,n),1000),\n    :exposure_i2=>exposure_petri(Symbol(:exp_i2, n), 6*social_mixing_rate[n][n]/pop[n], Symbol(:S,n), pop[n], Symbol(:I2,n), 1000, Symbol(:E,n),1000),\n    :exposure_a=>exposure_petri(Symbol(:exp_a, n), 5*social_mixing_rate[n][n]/pop[n], Symbol(:S,n), pop[n], Symbol(:A,n),1000, Symbol(:E,n),1000),\n    :progression=>spontaneous_petri(Symbol(:prog_, n), .25, Symbol(:I,n), 1000, Symbol(:I2,n), 1000),\n    :asymptomatic_infection=>spontaneous_petri(Symbol(:asymp_, n), .86/.14*.2, Symbol(:E,n), 1000, Symbol(:A,n), 1000),\n    :illness=>spontaneous_petri(Symbol(:ill_, n), .2, Symbol(:E,n), 1000, Symbol(:I,n), 1000),\n    :asymptomatic_recovery=>spontaneous_petri(Symbol(:arec_, n), 1/15, Symbol(:A,n), 1000, Symbol(:R,n), 0),\n    :recovery=>spontaneous_petri(Symbol(:rec_, n), 1/6, Symbol(:I2,n), 1000, Symbol(:R,n), 0),\n    :recover_late=>spontaneous_petri(Symbol(:rec2_, n), 1/15, Symbol(:R,n), 0, Symbol(:R2,n), 0),\n    :death=>spontaneous_petri(Symbol(:death2_, n), (1/15)*(fatality_rate[n]/(1-fatality_rate[n])), Symbol(:I2,n), 1000, Symbol(:D,n), 0)));\nnothing #hide","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Define the COEXIST model using the @relation macro","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"coexist = @relation (s, e, i, i2, a, r, r2, d) begin\n    exposure(s, i, e)\n    exposure_i2(s, i2, e)\n    exposure_a(s, a, e)\n    exposure_e(s, e, e)\n    asymptomatic_infection(e, a)\n    asymptomatic_recovery(a, r)\n    illness(e, i)\n    progression(i, i2)\n    death(i2, d)\n    recovery(i2, r)\n    recover_late(r, r2)\nend;\ndisplay_uwd(coexist)","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Define an oapply function that can be used to create a model of cross exposure between two sets of populations","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"F_cx(ex, x,y) = oapply(ex, Dict(\n    :exposure=>exposure_petri(Symbol(:exp_, x,y), 1*social_mixing_rate[x][y]/(pop[x]+pop[y]), Symbol(:S,x), pop[x], Symbol(:I,y), 1000, Symbol(:E,x), 1000),\n    :exposure_e=>exposure_petri(Symbol(:exp_e, x,y), .01*social_mixing_rate[x][y]/(pop[x]+pop[y]), Symbol(:S,x), pop[x], Symbol(:E,y),1000, Symbol(:E,x),1000),\n    :exposure_a=>exposure_petri(Symbol(:exp_a, x,y), 5*social_mixing_rate[x][y]/(pop[x]+pop[y]), Symbol(:S,x), pop[x], Symbol(:A,y),1000, Symbol(:E,x),1000),\n    :exposure_i2=>exposure_petri(Symbol(:exp_i2, x,y), 6*social_mixing_rate[x][y]/(pop[x]+pop[y]), Symbol(:S,x), pop[x], Symbol(:I2,y), 1000, Symbol(:E,x),1000),\n    :exposure′=>exposure_petri(Symbol(:exp_, y,x), 1*social_mixing_rate[y][x]/(pop[x]+pop[y]), Symbol(:S,y), pop[y], Symbol(:I,x), 1000, Symbol(:E,y), 1000),\n    :exposure_e′=>exposure_petri(Symbol(:exp_e, y,x), .01*social_mixing_rate[y][x]/(pop[x]+pop[y]), Symbol(:S,y), pop[y], Symbol(:E,x),1000, Symbol(:E,y),1000),\n    :exposure_a′=>exposure_petri(Symbol(:exp_a, y,x), 5*social_mixing_rate[y][x]/(pop[x]+pop[y]), Symbol(:S,y), pop[y], Symbol(:A,x),1000, Symbol(:E,y),1000),\n    :exposure_i2′=>exposure_petri(Symbol(:exp_i2, y,x), 6*social_mixing_rate[y][x]/(pop[x]+pop[y]), Symbol(:S,y), pop[y], Symbol(:I2,x), 1000, Symbol(:E,y),1000)\n  ),\n  Dict(\n    :s=>ob(Symbol(:S, x), pop[x]),\n    :e=>ob(Symbol(:E, x), 1000),\n    :a=>ob(Symbol(:A, x), 1000),\n    :i=>ob(Symbol(:I, x), 1000),\n    :i2=>ob(Symbol(:I2, x), 1000),\n    :r=>ob(Symbol(:R, x), 0),\n    :r2=>ob(Symbol(:R2, x), 0),\n    :d=>ob(Symbol(:D, x), 0),\n    :s′=>ob(Symbol(:S, y), pop[y]),\n    :e′=>ob(Symbol(:E, y), 1000),\n    :a′=>ob(Symbol(:A, y), 1000),\n    :i′=>ob(Symbol(:I, y), 1000),\n    :i2′=>ob(Symbol(:I2, y), 1000),\n    :r′=>ob(Symbol(:R, y), 0),\n    :r2′=>ob(Symbol(:R2, y), 0),\n    :d′=>ob(Symbol(:D, y), 0)\n  ));\nnothing #hide","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"Use this new presentation to define a model of cross exposure between two populations","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"crossexposure = @relation (s, e, i, i2, a, r, r2, d, s′, e′, i′, i2′, a′, r′, r2′, d′) begin\n    exposure(s, i′, e)\n    exposure_i2(s, i2′, e)\n    exposure_a(s, a′, e)\n    exposure_e(s, e′, e)\n    exposure′(s′, i, e′)\n    exposure_i2′(s′, i2, e′)\n    exposure_a′(s′, a, e′)\n    exposure_e′(s′, e, e′)\nend;\ndisplay_uwd(crossexposure)","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"To combine these two models, we need to create a final relational model and use the bundle_legs function in our oapply that enables us to model 3 population wires instead of each individual state as a wire. Each of these populations has their own COEXIST model, and interact through cross exposure","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"bundled_cross(x,y) = bundle_legs(F_cx(crossexposure, x, y), [tuple([1:8;]...), tuple([9:16;]...)])\nbundled_coex(x) = bundle_legs(F(coexist, x), [tuple([1:8;]...)])\nF_tcx(ex) = oapply(ex, Dict(\n    :crossexp12=>bundled_cross(3,4),\n    :crossexp13=>bundled_cross(3,5),\n    :crossexp23=>bundled_cross(4,5),\n    :coex1=>bundled_coex(3),\n    :coex2=>bundled_coex(4),\n    :coex3=>bundled_coex(5)));\n\nthreeNCoexist = @relation (pop1, pop2, pop3) begin\n    crossexp12(pop1, pop2)\n    crossexp13(pop1, pop3)\n    crossexp23(pop2, pop3)\n    coex1(pop1)\n    coex2(pop2)\n    coex3(pop3)\nend;\ndisplay_uwd(threeNCoexist)","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"threeNCoexist_algpetri = apex(F_tcx(threeNCoexist))\nto_graphviz(threeNCoexist_algpetri);\nsave_fig(to_graphviz(threeNCoexist_algpetri), \"3ncoexist_petri\", \"svg\"); # hide\nnothing #hide","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"(Image: 3-generation COEXIST model petri net)","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"We can use JSON to convert this Petri net into an easily shareable format","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"JSON.print(tables(threeNCoexist_algpetri), 2)","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"We can now easily generate a solver for DifferentialEquations.jl because we encoded the intitial parameters and rates throughout the construction of the model, the final result knows its concentrations and rates.","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"tspan = (0.0,100.0);\nprob = ODEProblem(vectorfield(threeNCoexist_algpetri),concentrations(threeNCoexist_algpetri),tspan,rates(threeNCoexist_algpetri));\nsol = solve(prob,Tsit5());\nplot(sol, xlabel=\"Time\", ylabel=\"Number of people\")","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"If we want to model other intervention methods, we can simply adjust the rates of exposure to represent stay at home orders and mask wearing. Because of how we have defined our rates, we can simply update the social mixing rates, and resolve the model.","category":"page"},{"location":"generated/covid/coexist/coexist/","page":"COEXIST Multi-Generational COVID Model","title":"COEXIST Multi-Generational COVID Model","text":"for i in 1:length(social_mixing_rate)\n  for j in 1:length(social_mixing_rate[1])\n    social_mixing_rate[i][j] = social_mixing_rate[i][j] / (i != j ? 10 : 5);\n  end\nend\nthreeNCoexist_algpetri = apex(F_tcx(threeNCoexist));\n\nprob = ODEProblem(vectorfield(threeNCoexist_algpetri),concentrations(threeNCoexist_algpetri),tspan,rates(threeNCoexist_algpetri));\nsol = solve(prob,Tsit5());\nplot(sol, xlabel=\"Time\", ylabel=\"Number of people\")","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/epidemiology.jl\"","category":"page"},{"location":"generated/covid/epidemiology/#epidemiology_example","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"","category":"section"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"(Image: )","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"using AlgebraicPetri\nusing AlgebraicPetri.Epidemiology\n\nusing LabelledArrays\nusing OrdinaryDiffEq\nusing Plots\n\nusing Catlab\nusing Catlab.Graphics\nusing Catlab.WiringDiagrams\nusing Catlab.CategoricalAlgebra\nusing Catlab.Programs.RelationalPrograms\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\nnothing #hide","category":"page"},{"location":"generated/covid/epidemiology/#SIR-Model:","page":"Basic Epidemiology Models","title":"SIR Model:","text":"","category":"section"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define model","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"sir = @relation (s,i,r) begin\n    infection(s,i)\n    recovery(i,r)\nend\ndisplay_uwd(sir)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"p_sir = apex(oapply_epi(sir))\nto_graphviz(p_sir)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define initial states and transition rates, then create, solve, and visualize ODE problem","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"u0 = LVector(S=10, I=1, R=0);\np = LVector(inf=0.4, rec=0.4);\nnothing #hide","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"The C-Set representation has direct support for generating a DiffEq vector field","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"prob = ODEProblem(vectorfield(p_sir),u0,(0.0,7.5),p);\nsol = solve(prob,Tsit5())\n\nplot(sol)","category":"page"},{"location":"generated/covid/epidemiology/#SEIR-Model:","page":"Basic Epidemiology Models","title":"SEIR Model:","text":"","category":"section"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define model","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"seir = @relation (s,e,i,r) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\nend\ndisplay_uwd(seir)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"p_seir = apex(oapply_epi(seir))\nto_graphviz(p_seir)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define initial states and transition rates, then create, solve, and visualize ODE problem","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"u0 = LVector(S=10, E=1, I=0, R=0);\np = LVector(exp=.9, ill=.2, rec=.5);\n\nprob = ODEProblem(vectorfield(p_seir),u0,(0.0,15.0),p);\nsol = solve(prob,Tsit5())\n\nplot(sol)","category":"page"},{"location":"generated/covid/epidemiology/#SEIRD-Model:","page":"Basic Epidemiology Models","title":"SEIRD Model:","text":"","category":"section"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define model","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"seird = @relation (s,e,i,r,d) begin\n    exposure(s,i,e)\n    illness(e,i)\n    recovery(i,r)\n    death(i,d)\nend\ndisplay_uwd(seird)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"p_seird = apex(oapply_epi(seird))\nto_graphviz(p_seird)","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"define initial states and transition rates, then create, solve, and visualize ODE problem","category":"page"},{"location":"generated/covid/epidemiology/","page":"Basic Epidemiology Models","title":"Basic Epidemiology Models","text":"u0 = LVector(S=10, E=1, I=0, R=0, D=0);\np = LVector(exp=0.9, ill=0.2, rec=0.5, death=0.1);\n\nprob = ODEProblem(vectorfield(p_seird),u0,(0.0,15.0),p);\nsol = solve(prob,Tsit5())\n\nplot(sol)","category":"page"},{"location":"generated/covid/chime/chime/","page":"-","title":"-","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/chime/chime.jl\"","category":"page"},{"location":"generated/covid/chime/chime/","page":"-","title":"-","text":"using AlgebraicPetri\nusing AlgebraicPetri.Epidemiology\n\nusing OrdinaryDiffEq\nusing LabelledArrays\nusing Plots\n\nusing Catlab.Theories\nusing Catlab.Graphics\nusing Catlab.CategoricalAlgebra\nusing Catlab.Programs.RelationalPrograms\n\ndisplay_uwd(ex) = to_graphviz(ex, box_labels=:name, junction_labels=:variable, edge_attrs=Dict(:len=>\".75\"));\n\nsir = @relation (s, i, r) where (s, i, r) begin\n    infection(s, i)\n    recovery(i, r)\nend\ndisplay_uwd(sir)","category":"page"},{"location":"generated/covid/chime/chime/","page":"-","title":"-","text":"p_sir = apex(oapply_epi(sir));\nto_graphviz(p_sir)\n\nu0 = LVector(S=990, I=10, R=0);\nt_span = (17.0,120.0)\n\nγ = 1/14\nβ = t->begin\n    policy_days = [20,60,120] .+ 17\n    contact_rate = 0.05\n    pol = findfirst(x->t<=x, policy_days) # array of days when policy changes\n    growth_rate = pol == 1 ? 0.0 : (2^(1/((pol-1)*5)) - 1) # growth rate depending on policy\n    return (growth_rate + γ) / 990 * (1-contact_rate) # calculate rate of infection\nend\np = LVector(inf=β, rec=γ);\n\nprob = ODEProblem(vectorfield(p_sir),u0,t_span,p)\nsol = OrdinaryDiffEq.solve(prob,Tsit5())\nplot(sol)\npng(\"ode-chime.png\")","category":"page"},{"location":"#AlgebraicPetri.jl","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"","category":"section"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"CurrentModule = AlgebraicPetri","category":"page"},{"location":"","page":"AlgebraicPetri.jl","title":"AlgebraicPetri.jl","text":"AlgebraicPetri.jl is a Julia library for building Petri net agent based models compositionally. This library acts as a bridge between Catlab.jl and Petri.jl. This package defines the category of Open Petri Nets as described in [Baez 2018].","category":"page"},{"location":"generated/covid/chime/chime-cset/","page":"-","title":"-","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/chime/chime-cset.jl\"","category":"page"},{"location":"generated/covid/chime/chime-cset/","page":"-","title":"-","text":"using AlgebraicPetri\nusing OrdinaryDiffEq\nusing Plots\nusing Catlab.Meta\nusing Catlab.CategoricalAlgebra\nusing Catlab.Graphics\nusing JSON\n\nimport OrdinaryDiffEq: ODEProblem\nODEProblem(p::LabelledReactionNet, t) = ODEProblem(vectorfield(p), concentrations(p), t, rates(p))","category":"page"},{"location":"generated/covid/chime/chime-cset/","page":"-","title":"-","text":"help capture JSON of defined functions","category":"page"},{"location":"generated/covid/chime/chime-cset/","page":"-","title":"-","text":"macro capture(funcname, exname, ex)\n    quote\n        $(esc(exname)) = $(repr(strip_lines(ex, recurse=true)))\n        $(esc(funcname)) = $ex\n    end\nend\n\n@capture γ γ_text 1/14\n@capture β β_text t->begin\n    policy_days = [20,60,120] .+ 17\n    contact_rate = 0.05\n    pol = findfirst(x->t<=x, policy_days) # array of days when policy changes\n    growth_rate = pol == 1 ? 0.0 : (2^(1/((pol-1)*5)) - 1) # growth rate depending on policy\n    return (growth_rate + γ) / 990 * (1-contact_rate) # calculate rate of infection\nend\n\nsir_cset= LabelledReactionNet{Function, Float64}((:S=>990, :I=>10, :R=>0), (:inf, β)=>((:S, :I)=>(:I,:I)), (:rec, t->γ)=>(:I=>:R))\n\nto_graphviz(sir_cset)\n\nprob = ODEProblem(sir_cset, (17.0, 120.0))\nsol = OrdinaryDiffEq.solve(prob,Tsit5())\nplot(sol)\n\n# Getting Sharable JSON\nsir_cset_string = LabelledReactionNet{String, Int}((:S=>990, :I=>10, :R=>0), (:inf, β_text)=>((:S, :I)=>(:I,:I)), (:rec, γ_text)=>(:I=>:R))\nJSON.print(tables(sir_cset_string), 2)","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicPetri.jl/blob/master/docs/literate/covid/stratification/stratification.jl\"","category":"page"},{"location":"generated/covid/stratification/stratification/#stratification_example","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"(Image: )","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"using AlgebraicPetri, AlgebraicPetri.TypedPetri\nusing Catlab.Programs, Catlab.Graphics\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing DisplayAs, Markdown","category":"page"},{"location":"generated/covid/stratification/stratification/#Define-basic-epidemiology-model","page":"Stratification of COVID Models","title":"Define basic epidemiology model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Define the type system for infectious disease models","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"const infectious_ontology = LabelledPetriNet(\n  [:Pop],\n  :infect => ((:Pop, :Pop) => (:Pop, :Pop)),\n  :disease => (:Pop => :Pop),\n  :strata => (:Pop => :Pop)\n)\n\nto_graphviz(infectious_ontology)","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Define a simple SIRD model with reflexive transitions typed as :strata to indicate which states can be stratified Here we add reflexive transitions to the susceptible, infected, and recovered populations but we leave out the dead population because they cannote do things such as get vaccinated or travel between regions.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"sird_uwd = @relation () where {(S::Pop, I::Pop, R::Pop, D::Pop)} begin\n  infect(S, I, I, I)\n  disease(I, R)\n  disease(I, D)\nend\n\nsird_model = oapply_typed(infectious_ontology, sird_uwd, [:infection, :recovery, :death])\nsird_model = add_reflexives(sird_model, [[:strata], [:strata], [:strata], []], infectious_ontology)\n\nto_graphviz(dom(sird_model))","category":"page"},{"location":"generated/covid/stratification/stratification/#Define-intervention-models","page":"Stratification of COVID Models","title":"Define intervention models","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/#Masking-model","page":"Stratification of COVID Models","title":"Masking model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"masking_uwd = @relation () where {(M::Pop, UM::Pop)} begin\n  disease(M, UM)\n  disease(UM, M)\n  infect(M, UM, M, UM)\n  infect(UM, UM, UM, UM)\nend\nmask_model = oapply_typed(infectious_ontology, masking_uwd, [:unmask, :mask, :infect_um, :infect_uu])\nmask_model = add_reflexives(mask_model, [[:strata], [:strata]], infectious_ontology)\n\nto_graphviz(dom(mask_model))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Stratify our SIRD model on this masking model to get a model of SIRD with masking:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"typed_product(sird_model, mask_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/covid/stratification/stratification/#Vaccine-model","page":"Stratification of COVID Models","title":"Vaccine model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"vax_uwd = @relation () where {(UV::Pop, V::Pop)} begin\n  strata(UV, V)\n  infect(V, V, V, V)\n  infect(V, UV, V, UV)\n  infect(UV, V, UV, V)\n  infect(UV, UV, UV, UV)\nend\nvax_model = oapply_typed(infectious_ontology, vax_uwd, [:vax, :infect_vv, :infect_uv, :infect_vu, :infect_uu])\nvax_model = add_reflexives(vax_model, [[:disease], [:disease]], infectious_ontology)\n\nto_graphviz(dom(vax_model))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Stratify our SIRD model on this vaccine model to get a model of SIRD with a vaccination rate:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"typed_product(sird_model, vax_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/covid/stratification/stratification/#Mask-Vax-Model","page":"Stratification of COVID Models","title":"Mask-Vax Model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"mask_vax_uwd = @relation () where {(UV_UM::Pop, UV_M::Pop, V_UM::Pop, V_M::Pop)} begin\n  strata(UV_UM, UV_M)\n  strata(UV_M, UV_UM)\n  strata(V_UM, V_M)\n  strata(V_M, V_UM)\n  strata(UV_UM, V_UM)\n  strata(UV_M, V_M)\n  infect(V_UM, V_UM, V_UM, V_UM)\n  infect(V_UM, UV_UM, V_UM, UV_UM)\n  infect(UV_UM, V_UM, UV_UM, V_UM)\n  infect(UV_UM, UV_UM, UV_UM, UV_UM)\n  infect(V_M, V_UM, V_M, V_UM)\n  infect(V_M, UV_UM, V_M, UV_UM)\n  infect(UV_M, V_UM, UV_M, V_UM)\n  infect(UV_M, UV_UM, UV_M, UV_UM)\nend\nmask_vax_model = oapply_typed(\n  infectious_ontology,\n  mask_vax_uwd,\n  [:mask_uv, :unmask_uv, :mask_v, :unmask_v, :vax_um, :vax_m, :infect_um_vv, :infect_um_uv, :infect_um_vu, :infect_um_uu, :infect_m_vv, :infect_m_uv, :infect_m_vu, :infect_m_uu]\n)\nmask_vax_model = add_reflexives(mask_vax_model, [[:disease], [:disease], [:disease], [:disease]], infectious_ontology)\n\nto_graphviz(dom(mask_vax_model))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Stratify our SIRD model on this mask + vaccine model to get a model of SIRD with a vaccination rate and masking policies:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"typed_product(sird_model, mask_vax_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/covid/stratification/stratification/#Define-geographic-models","page":"Stratification of COVID Models","title":"Define geographic models","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/#Travel-model-between-N-regions","page":"Stratification of COVID Models","title":"Travel model between N regions","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"For this model we can use a julia function to programmatically build up our undirected wiring diagram for defining this model. Here we want there to be N regions in which people can travel between each region and people within the same region are able to infect other people in the same region.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"function travel_model(n)\n  uwd = RelationalPrograms.TypedUnnamedRelationDiagram{Symbol,Symbol,Symbol}()\n  junctions = Dict(begin\n    junction = Symbol(\"Region$(i)\")\n    junction => add_junction!(uwd, :Pop, variable=junction)\n  end for i in 1:n)\n\n  pairs = filter(x -> first(x) != last(x), collect(Iterators.product(keys(junctions), keys(junctions))))\n  for pair in pairs\n    box = add_box!(uwd, [junction_type(uwd, junctions[p]) for p in pair], name=:strata)\n    for (rgn, port) in zip(pair, ports(uwd, box))\n      set_junction!(uwd, port, junctions[rgn])\n    end\n  end\n\n  act = oapply_typed(infectious_ontology, uwd, [Symbol(\"$(a)_$(b)\") for (a, b) in pairs])\n  add_reflexives(act, repeat([[:infect, :disease]], n), infectious_ontology)\nend\n\nto_graphviz(dom(travel_model(2)))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Stratify our SIRD model on this travel model with two regions:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"typed_product(sird_model, travel_model(2)) |> dom |> to_graphviz","category":"page"},{"location":"generated/covid/stratification/stratification/#Simple-Trip-model-between-N-regions","page":"Stratification of COVID Models","title":"Simple Trip model between N regions","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"For this model we can use a julia function to programmatically build up our model where people have the property of living somewhere and we are modelling them travelling between locations while maintaining the status of where they live.  Here we can actually just define the model of having a \"Living\" status and stratify it with the previously defined travel model to get a model of someone taking a simple trip.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"function living_model(n)\n  typed_living = pairwise_id_typed_petri(infectious_ontology, :Pop, :infect, [Symbol(\"Living$(i)\") for i in 1:n])\n  add_reflexives(typed_living, repeat([[:disease, :strata]], n), infectious_ontology)\nend\n\nto_graphviz(dom(living_model(2)))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"The resulting simple trip model:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"simple_trip_model = typed_product(travel_model(2), living_model(2))\nto_graphviz(dom(simple_trip_model))","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Stratify our SIRD model on this simple trip model between two regions:","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"typed_product(sird_model, simple_trip_model) |> dom |> to_graphviz","category":"page"},{"location":"generated/covid/stratification/stratification/#Stratification-of-COVID-models","page":"Stratification of COVID Models","title":"Stratification of COVID models","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"we set up a simple helper function to connect the undirected wiring diagrams to our infectious disease type system and add the necessary reflexive transitions for stratification.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"function oapply_mira_model(uwd)\n  model = oapply_typed(infectious_ontology, uwd, [Symbol(\"t$(n)\") for n in 1:nboxes(uwd)])\n  add_reflexives(model, [repeat([[:strata]], njunctions(uwd)-3)..., [], [:strata],[]], infectious_ontology)\nend","category":"page"},{"location":"generated/covid/stratification/stratification/#SIDARTHE-Model","page":"Stratification of COVID Models","title":"SIDARTHE Model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"BIOMD0000000955_miranet","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"m1_model = (@relation () where {(S::Pop, I::Pop, D::Pop, A::Pop, R::Pop, T::Pop, H::Pop, E::Pop)} begin\n  infect(S, D, I, D)\n  infect(S, A, I, A)\n  infect(S, R, I, R)\n  infect(S, I, I, I)\n  disease(I, D)\n  disease(I, A)\n  disease(I, H)\n  disease(D, R)\n  disease(D, H)\n  disease(A, R)\n  disease(A, H)\n  disease(A, T)\n  disease(R, T)\n  disease(R, H)\n  disease(T, E)\n  disease(T, H)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m1_model))","category":"page"},{"location":"generated/covid/stratification/stratification/#SEIAHRD-Model","page":"Stratification of COVID Models","title":"SEIAHRD Model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"BIOMD0000000960_miranet","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"m2_model = (@relation () where {(S::Pop, E::Pop, I::Pop, A::Pop, H::Pop, R::Pop, D::Pop)} begin\n  infect(S, I, E, I)\n  infect(S, A, E, A)\n  infect(S, H, E, H)\n  disease(E, I)\n  disease(E, A)\n  disease(I, H)\n  disease(I, R)\n  disease(I, D)\n  disease(A, R)\n  disease(A, D)\n  disease(H, D)\n  disease(H, R)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m2_model))","category":"page"},{"location":"generated/covid/stratification/stratification/#SEIuIrQRD-Model","page":"Stratification of COVID Models","title":"SEIuIrQRD Model","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"BIOMD0000000983_miranet","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"m3_model = (@relation () where {(S::Pop, E::Pop, Iu::Pop, Ir::Pop, Q::Pop, R::Pop, D::Pop)} begin\n  infect(S, Ir, E, Ir)\n  infect(S, Iu, E, Iu)\n  infect(S, Ir, Q, Ir)\n  infect(S, Iu, Q, Iu)\n  disease(Q, Ir)\n  disease(E, Ir)\n  disease(E, Iu)\n  disease(Ir, R)\n  disease(Iu, R)\n  disease(Q, S)\n  disease(Ir, D)\nend) |> oapply_mira_model\n\nto_graphviz(dom(m3_model))","category":"page"},{"location":"generated/covid/stratification/stratification/#Enumerating-stratified-models","page":"Stratification of COVID Models","title":"Enumerating stratified models","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"Next we can take all of our epidemiology, intervention, and geography models and easily enumerate and calculate the models for every possible stratification combination and investigate the resulting models with some set number of regions for the geographic stratification models.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"num_rgns = 5\ndisease_models = [(\"SIRD\", sird_model), (\"SIDARTHE\", m1_model), (\"SEIAHRD\", m2_model), (\"SEIuIrQRD\", m3_model)]\npolicy_models = [nothing, (\"Vaccination\", vax_model), (\"Masking\", mask_model), (\"Masking + Vaccination\", mask_vax_model)]\ntravel_models = [nothing, (\"Travel\", travel_model(num_rgns)), (\"Simple Trip\", typed_product(travel_model(num_rgns), living_model(num_rgns)))]\n\ntable = [\"| Model | Intervention | Geography ($(num_rgns) regions) | # of States | # of Transitons |\",\"|:--|$(repeat(\":-:|\", 4))\"]\n\nfor pieces in Iterators.product(disease_models, policy_models, travel_models)\n  petri = typed_product(last.(collect(filter(x -> !isnothing(x), pieces)))) |> dom\n  push!(table, \"|$(join([isnothing(piece) ? \"N/A\" : first(piece) for piece in pieces],\"|\"))|$(ns(petri))|$(nt(petri))|\")\nend\n\nMarkdown.parse(join(table, \"\\n\")) |> DisplayAs.HTML","category":"page"},{"location":"generated/covid/stratification/stratification/#Performance","page":"Stratification of COVID Models","title":"Performance","text":"","category":"section"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"As we increase the number of regions in our geographic stratification models, the number of states and transitions increase polynomially which causes the execution time for calculating the final stratified model to also increase polynomially.","category":"page"},{"location":"generated/covid/stratification/stratification/","page":"Stratification of COVID Models","title":"Stratification of COVID Models","text":"(Image: Runtime vs. Number of Georgraphic Regions)","category":"page"}]
}
